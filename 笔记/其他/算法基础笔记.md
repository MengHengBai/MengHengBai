# 什么是算法

## 算法的意义与重要性

决定程序的好坏的有：算法的 正确性、可维护性、可拓展性、健壮性、安全性等。**算法直接决定了程序是否可行**

高效算法让程序可行、高效、低占用

要点：输入、输出、有穷性、确定性、可行性.

## 例子

已知a+b+c=1000，且a^2+b^2=c^2，求a、b、c的所有自然数解

**1.枚举法**

```python
import time
start_time = time.time()

for a in range(1,1001):
    for b in range(1,1001):
        for c in range(1,1001):
            if a**2 + b**2 == c**2 and a+b+c=1000:
                print("a:%3d,b:%3d,c:%3d" % (a,b,c))

end_time = time.time()
print("程序已完成，总计时间%f" % (end_time - start_time))
```

**2.优化**

```python
import time
start_time = time.time()

for a in range(1,1001):
    for b in range(1,1001):
        for c in range(1,1001):
            if a**2 + b**2 == (1000-a-b)**2:
                print("a:%3d,b:%3d,c:%3d" % (a,b,1000-a-b))

end_time = time.time()
print("程序已完成，总计时间%f" % (end_time - start_time))
```

# 如何学习算法

## 多看

了解算法原理，理解一些经典算法。看算法的学习和讲解，**尽量多看一些相关书籍**

> 启蒙-初级：《啊哈！算法》、《算法图解》
>
> 中级：《数据结构与算法*》注意中英翻译细节，否则可能无法看完
>
> 终极（并不）：《算法导论》、《算法》第四版。注意发量

## 多练

刻意的练习，自己寻找习题。争取做到算法与程序都孰能生巧，**记得刷题**

[LeetCode](leetcode.com)，[leetCode](leetcode-cn.com)，[牛客网](www.nowcoder.com)。

我需要学习python和go吗？需要，提高算法水平和方便练习

## 多思考

了解算法的思考方式，而不能直接复制。活学活用

# 时间复杂度与大O表示法

## 注意：

* 算法的速度**不能**简单的以执行时间为衡量标准
* 随着输入数据的两极不断增大，操作数的增数是不同的

## 时间复杂度

将算法执行运算的操作数丢弃低阶项，再去掉所有系数。

## 大O表示法

在时间复杂度前添加一个O，就是大O表示法

```text
O(n)
```

## 示例

```python
n = 1000 #执行一次
k = 0    #执行一次

print(k);#执行一次

# 算法总共执行了3次
```

由于n执行了1次，所以用大O表示法是`O(1)`

```python
n = 1000             #执行1次
k = 0                #执行1次
for a in range(n):   #执行n次
    k+=1             #执行n次
print(k)             #执行1次
# 算法执行了2n+3次
```

去掉后面的低阶项，去掉2常项，表示为`O(n)`

## 常见的时间复杂度

|         操作数         | 时间复杂度 |  名称   |
| :--------------------: | :--------: | :-----: |
|          `3`           |   `O(1)`   |  常数   |
|      `105logn+2`       | `O(logn)`  |  对数   |
|         `2n+4`         |   `O(n)`   |  线性   |
|     `7n+9nlogn+39`     | `O(nlogn)` | `nlogn` |
|      `3n^2+2n+5`       |  `O(n^2)`  |  平方   |
| `n^3+20000n^2+3n+4101` |  `O(n^3)`  | 多项式  |
|         `2^n`          |  `O(2^n)`  |  指数   |

`O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)`

# 一般法则

## for循环

假设循环体的时间复杂度为`O(n)`，循环次数为m，则这个循环的时间复杂度为`O(n*m)`。

```python
n = 1000
k = 0
for a in range(n): # n次
    k += 1		   # O(1)
print(k)
```

`O(n*1)`=>`O(n)`

## 嵌套for循环

对于多个循环，假设循环体的时间复杂度为`O(n)`，各个循环的循环次数分别是a,b,c则这个循环的时间复杂度为`O(n*a*b*c)`，分析时要从内向外分析循环

## 顺序语句

各个语句的运行时间求和即可（或取最大值）

```python
n = 1000
k = 0

# 第一部分时间复杂度O(n)
for a in range(n):
    k += 1
    
# 第二部分时间复杂度O(n^2)
for a in range(n):
    for b in range(n):
        k += 1

print(k)
```

`O(n+n^2)`=>`O(n^2)`

## if/else语句

总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度

```python
n = 1000
k = 0
flag = 1

# 第一部分时间复杂度为O(n)
if flag >= 0:
    for a in range(n):
        k += 1

# 第二部分时间复杂度为O(n^2)
else:
    for a in range(n):
        for b in range(n):
            k += 1
```

`O(n^2)`

# 最后

程序设计有两种方式：一种方式是，使程序过于简单，明显没有缺陷；另一种方式是，使程序过于复杂，没有明显缺陷。——	`C.A.R Hoare`（快速排序算法发明者）
