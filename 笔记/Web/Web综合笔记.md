# Web性能优化（补充记忆）

## `<script>`阻塞渲染

* `<script>`包含影响DOM的方法，所以会阻塞渲染
* `<script defer>`不阻塞渲染，会按照顺序执行
* `<script async>`不阻塞渲染，加载完就会执行
* `<script type="module">`按需加载，按需执行
* `<script>`会影响`DOMContentLoaded`事件

优化方向：

+ 尽量将`<script>`放在`<body>`末尾
+ 添加`defer`或`async`属性
+ 业务无关的代码放在最后手动加载

## FCP(First Contentful Paint) 首屏渲染

+ FCP(First Contentful Paint)：第一次渲染的时间点，发生在`<head>`加载完成后
+ FCP不会影响渲染总时间，但对用户体验影响较大
+ 通常，期望FCP小于1秒

优化方向：

+ 关键样式放在`<head>`中
+ `<head>`中不放阻塞脚本
+ 首屏HTML放在一个闭合的标签里
+ 使用骨架屏

## CLS（Cumulative Layout Shift） 页面布局稳定性

+ 渲染过程中，页面出现大量布局变化，会影响用户体验
+ 所以在Google Web Vitals中，将CLS纳入考量

优化方向： 

+ 使用骨架屏
+ 减少使用web fonts
+ 给图片添加起始尺寸
+ 避免后期加载的内容导致页面变化

## LCP（Largest Contentful Paint）最大内容的渲染时间

+ 面积最大的内容，通常是最重要的内容
+ 所以Google Vitals

优化方向：

+ 将关键内容放在网页文件的前面
+ 通过样式的调整，满足产品的需要的同时，让关键内容更早渲染

## 加载资源

+ 同样的效果，体积可能大不一样
+ 优化资源，不仅能提升用户体验，还给自己省钱

优化方向：

+ 减少请求的资源
+ 压缩图片：位图（webp） 、 矢量svg
+ 压缩视频： mp4
+ 使用视频代替gif
+ 增加缓存时间

## 执行JS

单应用：

+ 所有JS都要优先执行
+ JS负责渲染页面
+ JS 的执行时间直接影响用户体验

## 执行效率

+ 原生API，性能更好
+ 新特性，通常有更好的优化效率
+ 静态代码更容易优化

优化方向： 

+ 在开发中多使用新特性，通过构建工具保证兼容性
+ 通过统计工具，照顾尽可能多的用户，但要适当提高目标平台的要求
+ 配置编译工具，尽可能使用原生API
+ 不要使用`eval`，`new Function()`等方法

## 代码量

+ 代码量越少，下载时间越短
+ 代码量越少，执行时间越短
+ 用户通常只需要20%的功能，不要让他们下载100%的代码

优化方向： 

+ 代码分模块，按需加载
+ 使用 ES Module ， 配合 http/2
+ 使用 tree-shaking
+ 使用高版本的第三方库

## 复用缓存

+ 代码分模块时，根据使用场景分组
+ 升级依赖的时候，尽量集中更新某个模块
+ 尽量让生成的代码具备一样的hash
+ 如果有多个项目，则尽量使用相同的分包

## SSR（Server Side Rendering ） 服务端渲染

+ 在服务器上渲染内容，再返回给客户端
+ 通常SPA需要等待JS执行完毕，再请求数据，再渲染页面
+ SSR可以让用户更早的看到内容，提升用户体验

优化方向：

+ 使用SSR框架，比如Nuxt.js， Next.js
+ 使用支持边缘计算和Serverless服务，比如Vercel
+ 使用预渲染提前渲染页面

## 为用户回访、站内跳转做准备

+ 静态资源保留较长时间的缓存
+ 加强资源复用，减少请求
+ 提前预缓存、预加载、本地化所需资源
+ 不长变得数据（例如头像），缓存一份

