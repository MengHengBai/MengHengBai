<link href="darkdown.css" rel="stylesheet"></link> 
<h1>go语言的开发环境</h1>
<h2>下载安装</h2>
<p><a href="https://golang.org">Go语言官网</a>，<a href="https://golang.google.cn/dl">Go语言谷歌中文镜像站</a>。</p>
<p>推荐从包源安装。</p>
<h2>go语言优势</h2>
<p>简单部署，直接编译机械码，编译后不依赖其它库，直接运行即可部署。</p>
<p>是一个静态语言，会在编译时检查问题。</p>
<p>跨平台，面向对象，支持C语法</p>
<p>编译时间顶层，运行时间仅次于C++。</p>
<h2>go语言的hello world</h2>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;hello golang!!!!&quot;)
}
</code></pre>
<p>可见以下特点：</p>
<ul>
<li>需要声明</li>
<li>导入的文件必须使用</li>
<li>可以写也可以不写分号</li>
</ul>
<h2>go语言的编译与运行</h2>
<p>使用命令<code>go help</code>调出帮助</p>
<p>使用<code>go run filename.go</code>尝试运行程序源文件</p>
<p>使用<code>go build filename.go</code>编译文件</p>
<h2>常见逻辑语法</h2>
<pre><code class="language-go">package main//声明一个包名

//import &quot;fmt&quot;
//import &quot;time&quot;
import {
    &quot;fmt&quot;
    &quot;time&quot;
}

func main(){
    fmt.Printf(&quot;Hello world!\n&quot;)
    time.Sleep(1*time.Second)//我直接倒地大睡1秒
}
</code></pre>
<pre><code class="language-go">package main

import {
    &quot;fmt&quot;
}

func main(){
	var a int//标准却有点别扭的声明变量方式
    fmt.Println(&quot;a = &quot;,a)//a = 0
    
    var b int = 100 //声明且赋值
    fmt.Println(&quot;b = &quot;,b) //b = 100
    fmt.Printf(&quot;type of b = %T\n&quot;,b) // type of b = int
    
    var c = 100 //自适应类型
    fmt.Println(&quot;c = &quot;,c) //c = 100
    fmt.Prinf(&quot;type of c = %T\n&quot;,c) //type of c = int
    
    d := 100 //常用方法 - 在某些情况下，该方法可以相当于new
    fmt.Println(&quot;d = &quot;,d) //100
    fmt.Printf(&quot;type od d = %T\n&quot;,d) // type of d = int
    
    const dgdtj int = 10 //常量
}
</code></pre>
<pre><code class="language-go">package main//语法糖
import &quot;fmt&quot;
func main(){
    fmt.Println(&quot;像这样的函数&quot;,&quot;其实可以传入很多的值&quot;,&quot;比如这样&quot;)
    var xx,yy int = 100,200 //声明很多变量 - 这在以后返回2个值的函数中常用
    var aa,bb = 123,&quot;wd***&quot; //支持很多类型
    var ( //多行格式化变量
    	vv int = 100
        jj bool = true
    )
    
    const { //定义枚举类型（大写
        A = 0
        B = 1
        C = 2
    }
    const { //自动累加 - 从0开始
        D = iota
        E
        F
    }
    const { //自动累加 - G = 1,J = 2, H = 3,K = 4 ......
        G,J = iota+1,iota+2 //可以使用其它运算符号
        H,K
        I,L
    }
}
</code></pre>
<p>以下是函数的定义</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func wd(){
    fmt.Println(&quot;wd&quot;)
}
func nm(a int){
    fmt.Println(a)
    return a
}
func d(b string){
    fmt.Println(b)
    return 100,&quot;wdadafeetgsuyehgr4fbutghfjm&quot;
}
func e() int {//返回一个int类型
    return 0
}
func d() (int,int){//返回2个int类型且匿名
    return 1,2
}
func f() (a int,b int){//返回且带有变量名
    a = 3
    b = 4
    return
}
func main(){
    wd()
    
    aa := nm(5)
    fmt.Println(aa)
    
    bb,cc := d(&quot;In The End...&quot;)
    fmt.Println(bb,cc)
    
    fmt.Println(e())
    
    ff,gg := f()
    fmt.Println(ff,gg)
    
    aaa,bbb = f()
    fmt.Println(aaa,bbb)
}
</code></pre>
<h2>导包问题</h2>
<p>导包时，可以导入自己写的包，此时，填写文件名，缺省后面的 .go ，可以多次嵌套，但注意不要循环</p>
<pre><code class="language-go">package main
import &quot;mygofile&quot;
func main(){
    mygofile.myfunc1()
}
</code></pre>
<p>可以通过相对路径，也可以通过绝对路径</p>
<pre><code class="language-go">package main
import &quot;C:\User\UserName\Desktop\MyGoFilw&quot;
func main(){
    MyGoFile.myfunc1()
}
</code></pre>
<p>如果不想写文件名，想直接导入，即使用匿名导入</p>
<pre><code class="language-go">package main
import _ &quot;MyGoFile&quot;
func main(){
    myfunc1()
}
</code></pre>
<p>这个符号用<code>.</code>也是可以的</p>
<p>同样，也可以使用别名</p>
<pre><code class="language-go">package main
import www &quot;MyGoFile&quot;
func main(){
    www.myfunc1()
}
</code></pre>
<h2>go语言中的指针</h2>
<p>和C语言指针一样，略</p>
<h2>defer语句的调用顺序</h2>
<p>简解：入栈式异步调用</p>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
func main(){
    defer Println(&quot;结束时执行，但是最后执行&quot;)
    defer Println(&quot;结束时执行，但是在最后执行之前执行&quot;)
    Println(&quot;优先执行&quot;)
    Println(&quot;之后执行&quot;)
}
</code></pre>
<h2>Go语言数组</h2>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
func a(ma [4]){
    ma[0] = 5
}
func main(){
    var myArray1 [10]int //静态固定长度数组
    for i := 0;i&lt;len(myArray1)li++ {
        Println(myArray1[i])
    }
    
    myArray2 := [4]int{1,2,3,4} //固定kv数组
    for index,value := range myArray2 {
        Println(&quot;index = &quot;,index,&quot;, value = &quot;,value)
    }
    
    a(myArray2) //指针传递 - 更改生效
}
</code></pre>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
func main(){
    myArr := []int{1,2,3,4} //动态数组 - 切片
    var a = make([]int,3,5) //make函数开辟一个空间
    Printf(&quot;%d  %d  %v  \n&quot;,len(a),cap(a),a) //长度  空间  值
    //在这个案例中，向a直接赋值a[3]是错误的，正确的做法应该是追加数据
    a = append(a,5) //向a追加一个元素位，值是5（len变化）
    // ............
    //若容器已满（cap=len），系统会自动扩容cap至原来的2倍，所以创建数组时要确定好cap的容量
}
</code></pre>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
func main(){
    a := []int{1,2,3}
    b := a[0,2] //从0开始，高位截瘫2位
    //但此过程不复制值
    
    copy(s1,s2) //从s2获取值传给s1 - 此时赋值值
}
</code></pre>
<h2>Map的声明与使用</h2>
<pre><code class="language-go">package main
func main(){
    var m1 map[string]string //声明一个map，k和v均为字符串类型
    m1 = make(map[string]string, 10) //给map分配空间
    
    m2 := make(map[string]string, 80) //简写
    
    m3 := map[string]string{ //最简（要make有什么用...）
        &quot;a&quot;:&quot;b&quot;
    }
    m3[&quot;c&quot;] = &quot;d&quot;
}
</code></pre>
<pre><code class="language-go">package main
func main(){
    //添加和遍历和数组相同，但是删除不同
    delete(m1,&quot;key&quot;)
}
</code></pre>
<h2>结构体</h2>
<pre><code class="language-go">type mi int //声明mi是int的别名
type Book struct{ //定义一个结构体（？？？）
    title	string
    auth	string
}
func main(){
    var book1 Book//book1 = new Book()
    book1.title = &quot;Go语言从入门到入土&quot;
    book1.auth = &quot;张三&quot;
}
</code></pre>
<p>此时产生的对象调用函数时是复制值传递，不会修改原本内容</p>
<h2>Go语言面向对象</h2>
<p><strong>注：此对象并不是现实中的对象，是一个虚化的，例子中的对象，与现实中的罗老师没有一点关系</strong></p>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
type Hero struct {
    Name string
    Ad	int
    L
}
func (this Hero) getname() {
    Println(&quot;Name = &quot;,this.Name)
}
func main(){
    hero := Hero{Name:&quot;罗老师&quot;, Ad: 100, L: 999}
    hero.getname()
}
</code></pre>
<p><strong>注：若结构体中的类别大写，则代表公开，否则代表私有</strong></p>
<pre><code class="language-go">package main
type a struct {
    A
}
type b struct {
    a //在b中继承a
    B
}
</code></pre>
<p>继承后，该重写的重写，该添加的添加</p>
<blockquote>
<p>结构体本质上是一个指针，可以用指针的全部技巧</p>
</blockquote>
<h2>接口</h2>
<p><code>interface{}</code> 是一个万能类型，也是一个空接口</p>
<pre><code class="language-go">package main
import . &quot;fmt&quot;
func a(a interface{}){ //此时传入后，需要手动判断数据类型
    value, ok := a.(string)
    if ok {
        Println(&quot;字符串&quot;,value)
    }else{
        Println(&quot;其他&quot;,value)
    }
}
func main(){
    b int = 5
    a(b)
}
</code></pre>
<h2>文件的读写</h2>
<blockquote>
<p>文案不完整</p>
</blockquote>
<pre><code class="language-go">package main
import {
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;io&quot;
}
func main(){
    tty,arr := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
    
    if err != nil {
        fmt.Println(&quot;openfileerr&quot;,err)
        return
    }
    
    var r io.Reader
    t = tty
    
    var w io.Writer
    w = r.(io.Writer)
}
</code></pre>
<h2>reflect反射</h2>
<pre><code class="language-go">package main
import {
    &quot;reflect&quot;
    &quot;fmt&quot;
}
func main(){
    var num float64 = 3.1415
    fmt.Println(reflect.TypeOf(num),reflect.ValueOf(num))
}
</code></pre>
<h2>结构体标签/别名</h2>
<pre><code class="language-go">package main
import {
    &quot;fmt&quot;
    &quot;reflect&quot;
}
type a struct {
    Name string `info:&quot;name&quot; doc:&quot;你的名字（与身份证号&quot;`
    Sex	string `info:&quot;sex&quot;`
}
func main(){
    var b a
    t := reflect.TypeOf(b).Elem()
    s := b.Field(0).Tag.Get(&quot;info&quot;)
    fmt.Println(s)
}
</code></pre>
<h2>多线程/go程</h2>
<pre><code class="language-go">package main
import {
    &quot;fmt&quot;
    &quot;time&quot;
}
func newTask() {
    i := 0
    for {
        i++
        fmt.Printf(&quot;new Goroutine : i = %d\n&quot;,i)
        time.Sleep(1*time.Second)
    }
}
func main(){
    go newTask() //创建新线程
    i := 0
    for {
        i++
        fmt.Printf(&quot;new Goroutine : i = %d\n&quot;,i)
        time.Sleep(1*time.Second)
    }
    //主函数一旦停止，其子线程也会停止
}
</code></pre>
<pre><code class="language-go">package main
import {
    &quot;fmt&quot;
    &quot;time&quot;
    &quot;runtime&quot;
}
func main(){
    go func() {
        defer fmt.Println(&quot;次线程结束&quot;)
        func () {
            defer fmt.Println(&quot;函数结束&quot;)
            runtime.Goexit() //退出线程而不是函数
            fmt.Println(&quot;函数执行&quot;)
        }
        fmt.Println(&quot;子线程运行&quot;)
    }()
    
    for { //睡死
        time.Sleep(1 * time.Second)
    }
}
</code></pre>
<h2>线程传递信息</h2>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main(){
    c := make(chan int) //定义一个管道
    go func(){
        defer fmt.Println(&quot;go程结束&quot;)
        fmt.Println(&quot;dfaeferfgrgsr&quot;)
        c &lt;- 666 //传递信息
    }
    num := &lt;-c //这里c和符号不能分开 - 此时main函数线程会阻塞并等待信息传递
    fmt.Println(num)
}
</code></pre>
<pre><code class="language-go">package main
import &quot;fmt&quot;
import &quot;time&quot;
func main(){
    c := make(chan int, 3) //缓冲区为3的管道，此时不取空或填满，对应的线程不会阻塞
    go func(){
        defer fmt.Println(&quot;go程结束&quot;)
        fmt.Println(&quot;dfaeferfgrgsr&quot;)
        c &lt;- 666 
        c &lt;- 777
        c &lt;- 888
    }
    
    time.Sleep(10*time.Second)
    
    num := &lt;-c //这里c和符号不能分开
    num1 := &lt;-c 
    num2 := &lt;-c
    fmt.Println(num,num1,num2)
}
</code></pre>
<p>在通道使用过程中，<code>close(c)</code>函数可以关闭一个管道，<code>if data, ok := &lt;-ok</code>，通过ok判断通道是否可用，data取出数据</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main(){
    c := make(chan int)
    
    go func(){
        for i := 0;i&lt;5;i++ {
            c &lt;- i
        }
        close(c)
    }
    
    for {
        if data,ok := &lt;-c; ok{ //从管道中获取数据，并以ok为判断条件
            fmt.Println(data)
        }else{
            break
        }
    }
}
</code></pre>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main(){
    c := make(chan int)
    
    go func(){
        for i := 0;i&lt;5;i++ {
            c &lt;- i
        }
        close(c)
    }
    
    for data := range c{ //使用range代替不断操作管道
        fmt.Println(data)
    }
}
</code></pre>
<p>单线程只能检测一个管道，<code>select</code>可以检测多个管道</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main(){
    c := make(chan int)
    quit := make(chan int)
    
    go func() {
        for i := 0;i&lt;6;i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }()
    
    x,y := 1,1
    for {
        select {//只会执行一次，所以设置循环
            case c &lt;- x: //如果c可写，则进入
            x = y
            y = x+y
            case &lt;-quit: //如果quit传值
            fmt.Println(&quot;quit&quot;)
            return
        }
    }
}
</code></pre>
<h1>图形界面</h1>
<pre><code class="language-go">package main

import {
    &quot;os&quot;
    &quot;github.com/mattn/go-gtk/gtk&quot;
}

func main() {
    gtk.Init(&amp;os.Args) //初始化
    
    win := gtk.NewWindow(gtk.WINDOW_TOPLEVEL) //带有边框的顶层窗口
    win.SetTitle(&quot;窗口标题&quot;)
    win.SetSizeRequest(400,400) //窗口大小
    win.SetPosition(gtk.WIN_POS_CENTER) //窗口居中
    win.SetResizable(false) //用户可以缩放
    
    var w, h int
    win.GetSize(&amp;w, &amp;h) //获得窗口大小
    
    win.Show() //展示窗口
    
    gtk.Main() //主窗口事件循环
}
</code></pre>
<h2>添加元素</h2>
<pre><code class="language-go">layout := gtl.NewFixed() //创建容器
win.Add(layout) //把容器塞进冰箱
b1 := gtk.NewButtonWithLabel(&quot;按钮1&quot;)
layout.Put(b1,0,0) //把按钮放在容器里
win.ShowAll() //避免写好多
gtk.Main()
</code></pre>
<h2>信号处理</h2>
<pre><code class="language-go">func HandleSignal(tmp string) {
    fmt.PrintLn(&quot;tmp = &quot;, tmp)
}
str := &quot;are u ok?&quot;
b1.Connect(&quot;clicked&quot;, HandelSignal, str) //把点击事件的信号交给HandelSignal函数，并传递str
</code></pre>
<pre><code class="language-go">func HandleSignal(ctx %glib.CallbackContext) {
    arg := ctx.Data() //用户传递的参数
    data, ok := arg.(string)
    if ok {
        fmt.Printf(&quot;按钮被按下， %s\n&quot;, data)
    }
}
</code></pre>
<pre><code class="language-go">b2.Connect(&quot;clicked&quot;, func() {
    fmt.Printf(&quot;按钮2被拍下，身价： %s\n&quot;, str)
})
</code></pre>
<p>窗口关闭：</p>
<pre><code class="language-go">win.Connect(&quot;destroy&quot;, func() {
    gtk.MainQuit() //gtk主程序关闭
})
</code></pre>
