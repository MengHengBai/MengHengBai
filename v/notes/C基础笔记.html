<link href="darkdown.css" rel="stylesheet"></link>
 <h3>存储单位</h3>
<table>
<thead>
<tr>
<th>单位</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>bit</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
</tr>
<tr>
<td>word</td>
<td>16</td>
</tr>
<tr>
<td>oword</td>
<td>32</td>
</tr>
</tbody>
</table>
<h3>计算机中存储数据的方式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据存储方式</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">原码</td>
<td style="text-align:center">最高位是符号位，0是正数，1是负数&lt;br /&gt;其他部分数据是原数据的绝对值的二进制数&lt;br /&gt;原码并不适合加减运算</td>
</tr>
<tr>
<td style="text-align:center">反码</td>
<td style="text-align:center">对于正数，反码与原码相同&lt;br /&gt;对于负数，符号位不变，其他位置取反&lt;br /&gt;反码只是原码转换成补码之前的过渡，并不适合运算</td>
</tr>
<tr>
<td style="text-align:center">补码</td>
<td style="text-align:center">在计算机系统中，数据一律采用补码存储&lt;br /&gt;补码统一了0的二进制数&lt;br /&gt;可以将符号位与其他位一起处理&lt;br /&gt;把减法运算变成了加法运算&lt;br /&gt;两个用补码表示的数想要相加时，如果符号位有进位，则进位被舍弃&lt;br /&gt;对于正数，补码与反码相同，对于负数，补码是它的反码+1</td>
</tr>
<tr>
<td style="text-align:center">运算</td>
<td style="text-align:center">可以通过符号位不变，其他位取反，然后+1的形式求原码</td>
</tr>
</tbody>
</table>
<h3>C语言中的switch语句</h3>
<pre><code class="language-c">switch(c){
    case '1':
        printf(&quot;1&quot;);
        break;
    case '2':
        printf(&quot;2&quot;);
        break;
}
</code></pre>
<p>其中，变量C<strong>只能</strong>是整形变量</p>
<h3>C语言中的字符串</h3>
<p>如果部分函数失效，需要导入头文件<code>#include &lt;string.h&gt;</code></p>
<h5>定义</h5>
<pre><code class="language-c">char a[] = {'a','b','\0'};
char b[] = &quot;ab&quot;;
</code></pre>
<p>只有像这样，字符串末尾有一个整型的0的字符数组，才被称之为<strong>字符串</strong></p>
<h5>指针字符串与普通字符串的区别（需要看完指针）</h5>
<p><code>char ch[]=&quot;hello world&quot;;</code>这种方式定义的字符串存储在栈区，称为<strong>栈区字符串</strong>，指针指向可以改变，内容可以改变</p>
<p><code>char* p=&quot;hello world&quot;;</code>这种方式定义的字符串存储在常量区，称为<strong>数据常量区字符串</strong>，指针指向可以改变，内容不可以改变</p>
<p>printf函数中直接传入的字符串也属于数据常量区字符串</p>
<h5>获取与使用</h5>
<p><code>gets(char* s)</code>可以获取字符串，遇到<strong>换行</strong>退出</p>
<p><code>scanf('%s',s);</code>可以获取字符串，遇到<strong>空格</strong>，<strong>逗号</strong>，<strong>换行</strong>时退出</p>
<p><code>fgets(char* s,int size,FILE *stream);</code>从stream流中读取字符串，读取<strong>size-1</strong>个字符，通常stream填写<code>stdin</code>以读取控制台内容</p>
<p><code>puts(char* s)</code>可以输出字符串</p>
<p><code>printf(&quot;%s&quot;,s)</code>可以输出字符串</p>
<p><code>fputs(const char* s,FILE *stream);</code>写入流文件，<strong>不写</strong>入末尾的<strong>0</strong>，通常stream填写<code>stdout</code>以输出到控制台</p>
<h5>格式化字符串</h5>
<pre><code class="language-c">char ch[100];
sprintf(ch,&quot;hello world&quot;);
printf('%s\n',ch);
</code></pre>
<pre><code class="language-c">int main(){
    char ch[100];
    sprintf(ch,&quot;%d+%d=%d&quot;,1,2,3);
    printf(&quot;%s\n&quot;,ch);
    return 0;
}
</code></pre>
<p>从<code>str</code>读取数据，根据<code>format</code>转换数据，返回转换的字符数量，-1表示失败</p>
<pre><code class="language-c">sscanf(const char *str,const char *format, ...);
</code></pre>
<pre><code class="language-C">char ch[] = &quot;1+2=3&quot;;
int a,b,c;
sscanf(ch,'%d+%d=%d',&amp;a,&amp;b,&amp;c);
printf(&quot;%d\n%d\n%d\n&quot;,a,b,c,);
</code></pre>
<p>从<code>str</code>读取数据，根据<code>format</code>给定的格式解析并输出</p>
<pre><code class="language-c">sprintf(char *str,const char *format, ...);
</code></pre>
<h5>字符串处理函数</h5>
<p>拷贝字符串，包括0</p>
<pre><code class="language-c">strcpy(char *dest,const char *src);
</code></pre>
<p>拷贝一定数量的字符，不会自动补充0</p>
<pre><code class="language-c">strncpy(char *dest,const char *src,size_t n);
</code></pre>
<p>字符串转换成数字</p>
<pre><code class="language-c">int a = atoi(const char *nptr);
float b = atof(const char *nptr);
long c = atol(const char *nptr)
</code></pre>
<p>字符串追加，包含0</p>
<pre><code class="language-C">strncat(char *dest,const char *src,size_t n);
</code></pre>
<p>比较字符串大小</p>
<pre><code class="language-C">strncmp(const char* s1,const char *s2,size_t n);
</code></pre>
<p><strong>字符串分割</strong></p>
<p>在<code>str</code>中以<code>delim</code>为分隔符分割字符串，以后将<code>str</code>设置为NULL即为继续分割。</p>
<p>成功返回地址，失败返回NULL。</p>
<p>这种方法会破坏原字符串，所以在调用之前需要备份</p>
<pre><code class="language-C">strtok(char *str,const char *delim);
</code></pre>
<p>字符串查找</p>
<p>在<code>haystack</code>中查找字符串<code>needle</code>出现的位置，失败返回NULL</p>
<pre><code class="language-c">strstr(const char *haystack,const char *needle);
</code></pre>
<p>字符串拼接</p>
<pre><code class="language-c">strcat(char *dest,const char *src);
</code></pre>
<p>字符查找</p>
<pre><code class="language-c">strchr(const char *s,int c);
</code></pre>
<h3>C语言获取系统时间和随机数</h3>
<p><code>time_t time(time_t *t);</code>获取当前时间戳，一般传入NULL，依赖<code>time.h</code>头文件</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
unsigned int seed = NULL;
void srand((unsigned int)seed); //设置种子
int a = rand(void); //返回随机数
int b = a % 50; //得到0-50区间的随机数
int c = a % 51 + 50; //得到50-100区间的随机数
</code></pre>
<h3>函数的声明与定义</h3>
<pre><code class="language-c">extern int name(int a,int b); //函数的声明
int name(int a,int b); //一般推荐使用
int name(int,int); //最简
</code></pre>
<p>通常，在主函数上面声明，下面定义</p>
<h3>指针</h3>
<p>定义：指针是存储内存地址的变量，无论什么类型，大小总是4或8，大小受32位或46位系统影响</p>
<p>特点：指针读取的内存地址将会随着指针类型变化</p>
<p><code>&amp;a</code>可以对a变量进行升维，但一次性只能升1层。</p>
<p><code>*a</code>可以对a变量进行降维，可以嵌套很多层。</p>
<p>通常，指针最多嵌套3层，其中1层最为常见。</p>
<h5>空指针和野指针</h5>
<table>
<thead>
<tr>
<th style="text-align:center">空指针</th>
<th style="text-align:center">野指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指针指向0内存空间，该内存受操作系统保护</td>
<td style="text-align:center">指针指向未知区域，<strong>通常</strong>受操作系统保护</td>
</tr>
<tr>
<td style="text-align:center">无法存取</td>
<td style="text-align:center"><strong>一般</strong>无法读取</td>
</tr>
</tbody>
</table>
<p>尽量在从程序中不出现野指针，不操作空指针。操作系统保留内存区域中的0-255区域，该区域禁止任何程序进行读写。</p>
<h5>万能指针</h5>
<p>万能指针并不是真的万能，只是它可以存储任何类型的指针，但是必须转型后才能使用。</p>
<p><code>void p = &amp;a;</code>这是一个万能指针，保存着a变量的地址</p>
<p><code>int* pp = (int*)p;</code>这是一个int*类型的变量，同样保存着a变量的地址，但是它的变量是由万能指针<strong>强制转型</strong>而来。</p>
<p>对万能指针直接进行操作会报错，原因是程序根本不知道一次性读取多少空间。</p>
<h5>const修饰的指针类型变量</h5>
<p>规则：const距离哪个比较近，就锁定哪个。</p>
<p><code>const int* a = &amp;b;</code>不能更改值，可以更改指向的位置</p>
<p><code>int* const a = &amp;b;</code>不能更改指向的位置，但可以更改值</p>
<p>如果两个const一起使用，则会彻底锁定，只有用更高层的指针才能解决</p>
<h5>数组？指针？</h5>
<p>当定义一个数组时，该数组名可以被看做一个指针，当这个数组被当做参数传入时，数组退化成指针同时丢失精度（丢失长度）</p>
<p>当数组被看做指针时不能直接被赋值，只能通过偏移量赋值，如果不注意容易数组下标越界</p>
<h5>指针之间的计算</h5>
<p>两个指针相减，得到的是两个指针之间的偏移量，结果总是一个整数，除以相应的类型以计算步长</p>
<p>指针的加减运算可以看做加减数组下标，步长移动的大小取决于变量类型，所以，不推荐不同类型的变量相互读取</p>
<p>指针之间乘除运算没有任何意义，但不会报错</p>
<h5>指针数组</h5>
<p><code>int* a[]={&amp;a,&amp;b};</code>指针数组里存放的全部都是指针，通过<code>char* arr[]={&quot;hello&quot;,&quot;world&quot;};</code>可以创建一个字符串数组，指针数组是一个特殊的二维数组结构</p>
<h5>指针与形参实参的关系</h5>
<p>当正常的参数传入时，函数只能通过返回值间接调整参数的值。但当传入的是一个指针时，不需要间接修改指针的值，因为参数可以通过指针达到修改的目的。可以把指针指向的位置视作全局变量。</p>
<h3>main函数中的参数</h3>
<p><code>int main(int argc,char* argv[]){}</code>以这种方式定义带参数的main函数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">全名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">argc</td>
<td style="text-align:center">arg count</td>
<td style="text-align:center">传入的参数的数量</td>
</tr>
<tr>
<td style="text-align:center">argv</td>
<td style="text-align:center">arg value</td>
<td style="text-align:center">传入的参数的内容</td>
</tr>
</tbody>
</table>
<p>特点：程序名本身也是一个参数，在<code>cmd -k &quot;cmd&quot;</code>中，cmd是第一个参数，-k是第二个参数，&quot;cmd&quot;是第三个参数。</p>
<h3>程序内存图</h3>
<table>
<thead>
<tr>
<th style="text-align:center">代码区：&lt;br /&gt;程序执行的二进制码&lt;br /&gt;共享只读</th>
<th style="text-align:center">数据区：&lt;br /&gt;1.初始化数据区&lt;br /&gt;2.为初始化数据区&lt;br /&gt;3.常量区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">栈区：&lt;br /&gt;系统为每一个程序分配一个临时的空间&lt;br /&gt;局部变量，函数信息，函数参数，数组&lt;br /&gt;栈区大小为1M&lt;br /&gt;在windows中最大是10M&lt;br /&gt;在Linux中最大16M</td>
<td style="text-align:center">堆区：&lt;br /&gt;通常存储大量数据，图片，音乐，视频等&lt;br /&gt;需要手动开辟和释放&lt;br /&gt;以指针为主要操作，可能会被其他程序破坏</td>
</tr>
</tbody>
</table>
<h3>枚举类型</h3>
<pre><code class="language-c">enum Name{
    v1,v2,v3
}
</code></pre>
<p>枚举有其相对应的值， 在枚举表中应列出所有可用值，也称为枚举元素。本身系统定义了一个表示序号的数值，默认从0开始定义，可以赋值，但会自动+-1式列数</p>
<h3>局部变量和全局变量</h3>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">作用域</th>
<th style="text-align:center">生命周期</th>
<th style="text-align:center">存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">局部变量</td>
<td style="text-align:center">函数内部</td>
<td style="text-align:center">从创建到函数结束</td>
<td style="text-align:center">栈区</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">项目中所有文件</td>
<td style="text-align:center">从程序创建到销毁</td>
<td style="text-align:center">数据区</td>
</tr>
<tr>
<td style="text-align:center">静态局部变量</td>
<td style="text-align:center">函数内部</td>
<td style="text-align:center">从创建到程序销毁</td>
<td style="text-align:center">数据区</td>
</tr>
<tr>
<td style="text-align:center">静态全局变量</td>
<td style="text-align:center">定义所在的文件中</td>
<td style="text-align:center">从程序创建到销毁</td>
<td style="text-align:center">数据区</td>
</tr>
</tbody>
</table>
<blockquote>
<p>静态变量用<code>static</code>修饰，只会定义一次，可以多次赋值</p>
</blockquote>
<h3>堆内存空间</h3>
<h5>定义</h5>
<p>堆内存空间是指一串连续的内存空间，通常用于临时存储大量数据。</p>
<pre><code class="language-c">char* a=(char*)malloc(sizeof(char)*大小);//创建空间
if(!a){//初始化
    memset(a,值,大小);
    //其他操作
    //释放
    free(a);
}
</code></pre>
<p><code>memset</code>函数第二个参数必须是<code>unsigned char</code>，值在0-255之间。</p>
<h5>堆空间操作函数</h5>
<p>拷贝<code>src</code>的<code>n</code>个内容到<code>dest</code>区，<strong>内存区域不可以重叠</strong></p>
<pre><code class="language-c">memcpy(void *dest,const void *src,size_t n);
</code></pre>
<h3>结构体</h3>
<h5>结构体的定义</h5>
<pre><code class="language-c">struct stu{
   int num;
   char name[20];
   char sex;
   int age;
   char addr[30];
} student;
</code></pre>
<p>其中，<code>struct stu</code>表示结构体类型名，<code>stu</code>可以没有。</p>
<p><code>student</code>表示结构体变量名，可以直接使用</p>
<p>通常，需要在主函数中重新定义一个结构体变量名：</p>
<pre><code class="language-c">int main(){
    struct stu Mike;
}
</code></pre>
<p><code>struct stu</code>可以看作一种数据类型</p>
<h5>结构体变量的操作</h5>
<p>可以对函数传入结构体参数,<em>此处两个知识点</em></p>
<pre><code class="language-c">void fun1(struct stu * const p){
    //不能对指向操作，可以操作值
    p-&gt;age=10;
}
</code></pre>
<pre><code class="language-c">void fun2(const strct stu * p){
    //不能操作值，可以操作指针指向
    p=NULL;
}
</code></pre>
<p>实例：</p>
<pre><code class="language-c">int main(){
    struct student stu;
    //因为数组退化成指针，所以不需要&amp;符号
    scanf(&quot;%s%d%d%s&quot;,stu.name,&amp;stu.age,&amp;stu.score,stu.addr);
    printf(&quot;姓名：%s\n&quot;,stu.name);
    printf(&quot;年龄：%s\n&quot;,stu.age);
    printf(&quot;成绩：%s\n&quot;,stu.score);
    printf(&quot;住址：%s\n&quot;,stu.addr);
    return 0;
}
</code></pre>
<p><strong>结构体数组略，大体与数组相同</strong></p>
<p><strong>结构体指针略，大体与指针相同</strong></p>
<p><strong>结构体指针数组略，大体与指针数组相同</strong></p>
<h3>联合体</h3>
<pre><code class="language-C">union Var{
    int a;
    float b;
    double c;
    char d;
    short d;
}
</code></pre>
<pre><code class="language-C">int main(){
    union Var var;
    var.a = 100;
    printf(&quot;%d\n&quot;,var.a);
    return 0;
}
</code></pre>
<p>该类型在存储时只支持存储其中一种类型的变量，在以其他类型读取时会出现异常的结果，可以存储任何类型的数据，包含自己</p>
<h3>文件操作</h3>
<h5>磁盘文件和设备文件</h5>
<p>磁盘文件：一组相关数据的有序集合，通常存储在外部介质上，调用时才输入内存。</p>
<p>设备文件：操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，输入输出等于读写。</p>
<h5>文件的打开</h5>
<pre><code class="language-c">FILE * fopen(const char * filename,const char * mode);
</code></pre>
<p><code>filename</code>：文件名，<code>mode</code>：读写模式</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(){
    File fp = fopen(&quot;a.txt&quot;,&quot;r&quot;);
    //fclose(fp);
    return 0;
}
</code></pre>
<p><code>mode</code>可以包含的模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">打开模式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r或rb</td>
<td style="text-align:center">以只读的方式打开一个文本或二进制文件</td>
</tr>
<tr>
<td style="text-align:center">w或wb</td>
<td style="text-align:center">以只写的方式打开一个文本或二进制文件</td>
</tr>
<tr>
<td style="text-align:center">a或ab</td>
<td style="text-align:center">以追加的方式打开一个文本或二进制文件</td>
</tr>
<tr>
<td style="text-align:center">r+或rb+</td>
<td style="text-align:center">以可读写的方式打开文件，不会创建文件</td>
</tr>
<tr>
<td style="text-align:center">w+或wb+</td>
<td style="text-align:center">以可读写的方式方式打开文件，清空或创建文件</td>
</tr>
<tr>
<td style="text-align:center">a+或ab+</td>
<td style="text-align:center">以添加的方式打开文件，打开文件末尾写入文件，否则创建文件</td>
</tr>
</tbody>
</table>
<p>b只是windows中的模式，在linux中r和rb一样</p>
<h5>文件的关闭</h5>
<pre><code class="language-c">fclose(fp);
</code></pre>
<h5>文件的读写</h5>
<pre><code class="language-c">fputc(int ch,FILE * stream);
</code></pre>
<p>将ch转换为unsigned char并写入文件</p>
<pre><code class="language-c">fgetc(FILE * stream);
</code></pre>
<p>从stream中读取一个字符，成功返回字符，失败返回NULL</p>
<pre><code class="language-c">fprintf(FILE * stream,const char * format, ...);
</code></pre>
<p>根据<code>format</code>格式化数据，并输出在stream</p>
<pre><code class="language-c">fseek(FILE *stream, long offset,int whence);
</code></pre>
<p>移动文件流光标位置，<code>stream</code>文件流，<code>offset</code>根据<code>whence</code>移动的偏移量</p>
<pre><code class="language-c">ftell(FILE *stream);
</code></pre>
<p>获取光标位置</p>
<pre><code class="language-c">fputs(const char * str,FILE * stream);
</code></pre>
<p>把<code>str</code>写入<code>stream</code>，不包含0</p>
<pre><code class="language-c">fwrite(const void *ptr,size_t size,size_t nmemb,FILE *stream);
</code></pre>
<p><code>ptr</code>准备写入的文件地址，<code>size</code>未标识的int类型，<code>nmemb</code>写入文件的块数，<code>stream</code>文件指针</p>
<pre><code class="language-c">fscanf(FILE * stream,const char * format, ...);
</code></pre>
<p>根据<code>format</code>读取<code>stream</code>中的文件</p>
<pre><code class="language-c">fgets(char *s,int size,FILE *stream);
</code></pre>
<p>读取<code>size</code>大小的文件内容到<code>s</code>，遇到换行空格结尾停止</p>
<pre><code class="language-c">fputs(const char * str,FILE * stream);
</code></pre>
<p>写入文件不包含0</p>
<h5>文件结尾</h5>
<p>在文件结尾，将会返回一个-1,其在编译器定义为<code>EOF</code>。</p>
<p>这种返回必须是文本文件，否则将不会返回<code>EOF</code></p>
<h5>文件的删除和重命名</h5>
<pre><code class="language-c">remove(const char* pathname);
</code></pre>
<p>删除一个文件/目录，成功0,失败1</p>
<pre><code class="language-c">rename(const char* oldname,const char* newname);
</code></pre>
<p>重命名文件/目录，成功0,失败1</p>
<p>也可以使用此方法移动文件</p>
<h5>文件缓冲区</h5>
<p>C语言中会自动建立文件缓冲区，通过以下方法释放缓冲区</p>
<pre><code class="language-c">fflush(FILE* stream);
</code></pre>
<p>成功返回0,失败返回-1</p>
<h3>typedef</h3>
<p><code>typedef</code>是关键字，可以将一种数据类型定义一个其他简称，但不能定义数据。</p>
<p>发生在编译阶段，而<code>#define</code>发生在预处理阶段</p>
<pre><code class="language-c">typedef unsigned int ui;
</code></pre>
<p>把<code>unsigned int</code>简写成<code>ui</code></p>
<h3>索引</h3>
<p>索引是为了避免for循环时间过长出现的，原理：</p>
<p>记录某个词的首字母/首词出现的区间，在区间内进行循环查找，减少for循环占用的时间</p>
