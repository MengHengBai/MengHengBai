<link href="http://github.com/yrgoldteeth/darkdowncss/raw/master/darkdown.css" rel="stylesheet"></link> 
<h2>导入和导出</h2>
<p>导出多个成员</p>
<pre><code class="language-javascript">exports.a = 123
exports.b = 'hello'
exports.c = function () {
    console.log('wafef')
}
exports.d = {
    foo: 'bar'
}
</code></pre>
<p>导出单个成员，且覆盖</p>
<pre><code class="language-javascript">module.exports = 'hello3'
</code></pre>
<pre><code class="language-javascript">module.exports = {
    add: function(){
        return 502
    }
    str: 'hello'
}
</code></pre>
<p>导入： 由于底层设计，可以防止数据被重复导入</p>
<pre><code class="language-javascript">require('./a')
let fn = require('./b')
console.log(fn)
</code></pre>
<pre><code class="language-javascript">console.log('a.js 被加载了')
let fn = require('./b')
console.log(fn)
</code></pre>
<pre><code class="language-javascript">console.log('b.js 被加载了')
module.exports = function () {
    console.log('hello b')
}
</code></pre>
<h2>url统一资源定位器</h2>
<pre><code class="language-javascript">const url = require(&quot;url&quot;)
let obj = url.parse('/pinglun?name=卢本伟&amp;message=再见', true)
</code></pre>
<p>此对象会返回如下对象，均可进行调用</p>
<pre><code class="language-javascript">{
    protocal: null,
    slashes: null,
    auth: null,
    host: null,
    port: null,
    hostname: null,
    hash: null,
    search: '?name=卢本伟&amp;message=再见',
    query: 'name=卢本伟&amp;message=再见',
    pathname: '/pinglun',
    path: '/pinglun?name=卢本伟&amp;message=再见',
    href: '/pinglun?name=卢本伟&amp;message=再见'
}
</code></pre>
<h2>Express</h2>
<p>express是一个第三方Web开发框架，其高度封装了http模块，使用时更加专注于业务，而不是底层逻辑</p>
<pre><code class="language-javascript">const express = require('express')
let app = express() //服务器对象
app.get('/', (a,s)=&gt;{ //处理get请求
    s.send('hello world')
})
app.listen(80, ()=&gt;{ //监听端口
    console.log('App is running at port 80.')
})
</code></pre>
<pre><code class="language-javascript">const express = require('express')
let app = express() 
app.use('/', express.static('./public/')) //设置静态资源路径 - 127.0.0.1/public/abc.txt
app.use(express.static('./public/')) //127.0.0.1/abc.txt
app //优化写法
	.get('/login', function(){})
	.get('/dsadsa', function(){})
	.post('/d/sadsa',function(){})
app.get('/', (a,s)=&gt;{
    s.redirect('/') //重定向
})
app.listen(80, ()=&gt;{ 
    console.log('App is running at port 80.')
})
</code></pre>
<pre><code class="language-javascript">// 由于express把中间件分离
app.use(require('body-parser').json());
// 创建 application/x-www-form-urlencoded 编码解析
app.use(bodyParser.urlencoded({ extended: true })); //json通常用true，字符串通常用false 
app.post('/post',(a,s)=&gt;{
    s.send(a.body) //回传post的数据
})
</code></pre>
<h2>Event模块</h2>
<pre><code class="language-javascript">const EventEmitter = require(&quot;events&quot;)
const myEvent = new EventEmitter()

myEvent.on('事件1', ()=&gt;{
    console.log(&quot;事件1执行了&quot;)
})
myEvent.on('事件1', ()=&gt;{
    console.log(&quot;事件1 - 2执行了&quot;)
})
myEvent.once('事件1', ()=&gt;{
    console.log('事件1首次执行')
})

myEvent.emit('事件1') //调用
myEvent.off('事件1') //关闭
myEvent.off('事件1', ()=&gt;{
    console.log('事件1更换函数')
})
</code></pre>
<pre><code class="language-javascript">const EventEmitter = require(&quot;events&quot;)
const ev = new EventEmitter()
ev.on('a',(a,b,c)=&gt;{
    console.log(a+b+c)
})
ev.emit('a',1,2,3) //传值
</code></pre>
<h2>process模块</h2>
<pre><code class="language-javascript">const process = require(&quot;process&quot;)

//1. cpu内存
console.log(process.memoryUsage())
console.log(process.cpuUsage())

//2. 运行环境： 运行目录、node环境、cpu架构、用户环境、系统平台
console.log(process.cwd())
console.log(process.version)
//console.log(process.versions)
console.log(process.arch)
console.log(process.env.NODE_ENV)
//console.log(process.env.PATH)
console.log(process.env.USERPROFILE)
console.log(process.platform)

//3. 运行状态： 启动参数、PID、运行时间
console.log(process.argv)
console.log(process.argv0)

//4. 事件
process.on('exit', (code)=&gt;{
    console.log('exit' + code)
})
process.on('beforeExit',(code)=&gt;{
    console.log('beforeExit' + code)
})
</code></pre>
<p>##　fs模块</p>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)

//open
fs.open(path.resolve('data.txt'),'r',(err,fd)=&gt;{
    console.log(fd)
})
//close
fs.open(path.resolve('data.txt'),'r',(err,fd)=&gt;{
    console.log(fd)
    fs.close(fd,err=&gt;{
        console.log('关闭成功')
    })
})
</code></pre>
<p>fs模块常见API</p>
<table>
<thead>
<tr>
<th style="text-align:center">access</th>
<th style="text-align:center">判断文件或目录是否具有操作权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">stat</td>
<td style="text-align:center">获取目录及文件信息</td>
</tr>
<tr>
<td style="text-align:center">mkdir</td>
<td style="text-align:center">创建目录</td>
</tr>
<tr>
<td style="text-align:center">rmdir</td>
<td style="text-align:center">删除目录</td>
</tr>
<tr>
<td style="text-align:center">readdir</td>
<td style="text-align:center">读取目录内容</td>
</tr>
<tr>
<td style="text-align:center">unlink</td>
<td style="text-align:center">删除指定文件</td>
</tr>
</tbody>
</table>
<h2>文件读写缓冲 - buffer</h2>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;)

//read - 将数据从磁盘中写入到buffer中
let buf = Buffer.alloc(10)
fs.open('data.txt', 'r', (err, rfd)=&gt;{
    console.log(rfd)
    fs.read(rfd, buf, 0, 3, 0, (err, readBytes, data)=&gt; {
        console.log(readBytes)
        console.log(data)
        console.log(data.toString())
    })
})
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">fd</th>
<th style="text-align:center">定位当前被打开的文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">buf</td>
<td style="text-align:center">用于表示当前缓冲区</td>
</tr>
<tr>
<td style="text-align:center">offset</td>
<td style="text-align:center">当前从buf哪个位置开始写入</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">表示当前次写入的长度</td>
</tr>
<tr>
<td style="text-align:center">position</td>
<td style="text-align:center">表示当前从文件的哪个位置开始读取</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">//write - 将缓冲区里的文件写入到磁盘文件中
buf = Buffer.from('1234567890')
fs.open('b.txt','w',(err,wfd)=&gt;{
    fs.write(wfd,buf,0,3,0, (err,written,buffer)=&gt;{ //同上
        console.log(written)
        console.log(buffer)
        console.log(buffer.toString())
    })
})
</code></pre>
<p>##　process - fs 读写IO流</p>
<pre><code class="language-javascript">const fs = require('fs')
const process = require('process')

fs.createReadStream('test.txt')
	.pipe(process.stdout) //对接

//底层 - 背压机制（官方已封装）
process.stdin.setEncoding('utf-8')
process.stdin.on('readable',()=&gt;{
    let chunk = process.stdin.read()
    if(chunk !== null) {
        process.stdout.write('data' + chunk)
    }
})
</code></pre>
<p>nodejs中流的分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">Readable</th>
<th style="text-align:center">可读流，能够实现数据的读取</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Writeable</td>
<td style="text-align:center">可写流，能够实现数据的写操作</td>
</tr>
<tr>
<td style="text-align:center">Duplex</td>
<td style="text-align:center">双工流，可读可写</td>
</tr>
<tr>
<td style="text-align:center">Tranform</td>
<td style="text-align:center">转换流，可读可写可转换</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;)

let rs = fs.createReadStream('./test.txt')
let ws = fs.createWriteStream('./test1.txt')

rs.pipe(ws) //对接
</code></pre>
<pre><code class="language-javascript">const fs = require('fs')
const rs = fs.createReadStream('00-note.txt')
rs.pipe(process.stdout)
</code></pre>
<pre><code class="language-javascript">//底层
const fs = require('fs')
//创建一个产生数据的可读流
let rs = fs.createReadStream('00-note.txt')
//调整编码
rs.setEncodeing('utf-8')
//创建一个消费数据的可写流
let ws = fs.createWriteStream('01-note.txt')
//监听事件调用方法完成具体的消费
rs.on('data',(chunk)=&gt;{
    //执行数据写入
    ws.write(chunk)
})
</code></pre>
<h2>双工流       Duplex&amp;&amp;Transform</h2>
<pre><code class="language-javascript">const {Transform} = require('stream')

class MyTransform extends Transform {
    constructor(options) {
        super()
    }
    _transform (chunk, encoding, callback) {
        this.push(chunk.toString().toUpperCase())
        callback(null)
    }
}

let a = new MyTransform()

a.write('a')
a.write('b')
a.end('c')

a.pipe(process.stdout)
</code></pre>
<h2>log4j（？）</h2>
<pre><code class="language-javascript">let content = fs.readFileSync('test.txt', 'utf-8')
eval(content)
vm.runInThisContext(content)
console.log(age)
</code></pre>
<h2>异步执行</h2>
<pre><code class="language-javascript">setTimeout(()=&gt;{
    console.log('s1')
    Promise.resolve().then(()=&gt;{
        console.log('p1')
    })
    Promise.resolve().then(()=&gt;{
        console.log('p2')
    })
})
</code></pre>
<p>结果： s1, p1, p2, 其他代码</p>
<p>完整事件执行顺序：</p>
<ul>
<li>从上至下执行所有的同步代码</li>
<li>执行过程中将遇到的宏任务与微任务添加至相应的队列</li>
<li>同步代码执行完毕后，执行满足条件的为任务回调</li>
<li>微任务队列执行完毕后执行所有满足需要的宏任务回调</li>
<li>循环事件环操作</li>
<li>注意： 每执行一个宏任务之后就会立即检查微任务</li>
</ul>
<p>优先级： <code>nodejs</code>中<code>process.nextTick</code>先于<code>promise.then</code></p>
<h2>进度条</h2>
<pre><code class="language-javascript">const log = require('single-line-log').stdout

const blockChar = '='
const emptyChar = '+'

const renderProgress = (finished,total)=&gt;{
    //进度条长度
    const blockLen = 50
    //计算进度，并根据进度计算实心块显示个数
    const completed = Math.floor(finished/total*100/(100/blockLen))
    let result = ''
    //显示块
    for(let i=0;i&lt;completed;i++)result+=blockChar
    for(let i=0;=&lt;blockLen-completed;i++)result+=emptyChar
    //进度文字
    result+=`${Math.floor(finished/total*100)}% ${finished}|${total}`
    return result
}
</code></pre>
<pre><code class="language-javascript">//模拟下载进度
let total = 100
let finished = 0
setInterval(()=&gt;{
    finished++
    if(finished&lt;=total){
        //使用single-line-log，将内容显示在同一行
        log(renderProgress(finished,total))
    }
},20)
</code></pre>
<h2>网络通信</h2>
<h3>常见控制字段</h3>
<ul>
<li>SYN = 1 表示请求建立链接</li>
<li>FIN = 1表示请求断开连接</li>
<li>ACK = 1 表示数据信息确认</li>
</ul>
<h3>创建tcp连接</h3>
<p>创建服务端实例</p>
<pre><code class="language-javascript">const net = require(&quot;net&quot;)
const server = net.createServer()
server.listen(8000, '127.0.0.1')

server.on('listening', ()=&gt;{ //监听成功事件
    console.log('Server wasd opend')
})
server.on('connection',(socket)=&gt;{ //连接成功事件
    socket.on('data',(chunk)=&gt;{ // 接收消息
        const msg = chunk.toString()
        socket.write(Buffer.from('Got it! '+msg)) //回写数据
    })
})
server.on('error',(err)=&gt;{
    if(err.code=='EADDRINUSE'){
        console.log(&quot;地址正在使用&quot;)
    }else{
        console.log(&quot;出错了&quot;+err)
    }
})
server.on('close',()=&gt;{
    console.log(&quot;服务端断开&quot;)
})
</code></pre>
<p>创建客户端</p>
<pre><code class="language-javascript">const net = require('net')
const client = net.createConnection({
    port: 1234,
    host: '127.0.0.1'
})
client.on('connect',()=&gt;{
    client.write('拉钩教育')
})
client.on('data',(chunk)=&gt;{
    console.log(chunk.toString())
})
client.on('error',(err)=&gt;{
    console.log(err)
})
client.on('close',()=&gt;{
    console.log(&quot;客户端断开&quot;)
})
</code></pre>
<h3>TCP数据粘包</h3>
<p>发送端会累积数据统一发送（并不会超时），接收端会缓冲数据之后再消费。这时会由TCP拥塞机制决定发送时机。</p>
<p>通常解决办法有延时发送和封包拆包，其中，常用数据的封包拆包。</p>
<pre><code class="language-shell">发送： abab aba bab
接收： ababababab
</code></pre>
<h3>数据的拆包与拆包</h3>
<p>数据传输过程： 进行数据编码，获得二进制数据包》按规则拆解数据，获取指定长度的数据。</p>
<p>其中，数据由消息头和消息体构成，消息头中通常包含序列号，数据长度等信息。按照预先规定好的协议解读即可。</p>
<p>这涉及到Buffer数据读写，使用<code>writeInt16BE</code>函数去写入，使用<code>readInt16BE</code>去读出。</p>
<h3>http</h3>
<p>基础服务器</p>
<pre><code class="language-javascript">const http = require(&quot;http&quot;)
http.createServer((a,s)=&gt;{
    //s.statusCode = 200
    s.statusCode = 302
    s.setHeader('Content-type', 'text/html;charset=utf-8')
    s.setHeader('Location', '/')
    s.end()
}).listen(80)
</code></pre>
<p>请求相关信息</p>
<pre><code class="language-javascript">const http = require(&quot;http&quot;)
const url = require(&quot;url&quot;)

http.createServer((a,s)=&gt;{
    //请求路径
    let {pathname, query} = url.parse(a.url, true)
    console.log(pathname, '--------', query)
    //请求方式
    console.log(a.method)
    //http版本
    console.log(a.httpVersion)
    //请求头
    console.log(a.headers)
    console.log(a.headers['content-type'])
    //请求体(post)
    let arr = new Array()
    a.on('data',(data)=&gt;{
        arr.push(data)
    })
    a.on('end',()=&gt;{
        console.log(Buffer.concat(arr),toString())
    })
}).listen(8080)
</code></pre>
<h3>http请求发送</h3>
<pre><code class="language-javascript">const http = require('http')

//http.get({
//    host: 'localhost',
//    port: 1234,
//    path: '/a?b=1'
//},(res)=&gt;{
//    //
//})

let options = {
    host: 'localhost',
    port: 1234,
    path: '/?a=1',
    method: 'POST',
    headers: {
        'Content-type': 'application/json'
    }
}

let req = http.request(options, (res)=&gt;{
    let arr = []
    res.on('data',(data)=&gt;{
        arr.push(data)
    })
    res.on('end',()=&gt;{
        console.log(Buffer.concat(arr).toString())
    })
})

req.end('{&quot;key&quot;, &quot;value&quot;}')
</code></pre>
