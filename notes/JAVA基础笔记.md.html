<h1>JAVA笔记</h1>
<h3>程序开头---package</h3>
<p><code>package com.sun.index.indexmodles.javalang.lang;</code>定义一个程序包，相当于路径。</p>
<p>规则：</p>
<p>​    该语句只能出现在程序语句的第一句，上面可以有注释。</p>
<p>​    形式为 com.公司域名倒叙.项目名.模块名.功能名</p>
<h3>public class</h3>
<p>在一个java源文件中，只能有一个public class，但可以有多个class。必须有一个class是与文件名一致的，但是可以没有public修饰</p>
<h3>基本数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">修饰</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">1字节</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">2字节</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">4字节</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">8字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">浮点数</td>
<td style="text-align:center">4字节</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">浮点数</td>
<td style="text-align:center">8字节</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">1字节</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">字符</td>
<td style="text-align:center">2字节</td>
</tr>
</tbody>
</table>
<h3>异常捕获</h3>
<h5>捕获异常</h5>
<p>可以使用try...catch...finally语句或throws语句处理异常</p>
<pre><code class="language-java">class a throws Exception{
    1/0;
}
class a{
    try{
        1/0
    }catch(Exception e){
        e.printStackTrace(); //打印错误堆栈
        e.getMessage(); //获取错误信息
    }finally{
        System.out.println(&quot;这个语句块中的代码一定会被执行&quot;)
    }
}
</code></pre>
<h5>手动抛出异常</h5>
<pre><code class="language-java">xxx e = xxx(&quot;msg&quot;);
throw e;
</code></pre>
<h3>包装类对象 - 自动装箱与自动拆箱</h3>
<table>
<thead>
<tr>
<th style="text-align:center">原类型</th>
<th style="text-align:center">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>java.lang.Integer</strong></td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">java.lang.byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">java.lang.Short</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">java.lang.Long</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">java.lang.Double</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">java.lang.Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center"><strong>java.lang.Character</strong></td>
</tr>
</tbody>
</table>
<p>现在的JDK将会自动进行自动装箱与自动装箱</p>
<h3>数组</h3>
<p>静态初始化一维数组<code>int[] c1 = (0,1,2,3,4,5,6,7,8,9);</code>，静态初始化二维数组<code>int[][] d1 =((1,2,3),(1,2,3));</code>。</p>
<p>动态初始化</p>
<pre><code class="language-java">int[] a1 = new int[5];
int[] b1 = new int[1][2];
</code></pre>
<h3>关于类</h3>
<h5>类的继承</h5>
<pre><code class="language-java">class a extends b{
    //a类中重写b类中的方法
}
</code></pre>
<h5>构造方法</h5>
<pre><code class="language-java">class name{
    f(){
        //无参数构造方法，用处不大但至关重要
    }
    f(int a){
        //有参数的构造方法，与无参数构造方法构成方法重载
    }
}
</code></pre>
<p>构造方法不能写返回值，相当于有void关键字修饰</p>
<h5>super关键字</h5>
<p>super不是引用类型，其中存储的不是内存地址，且指向的不是父类对象。super代表的是当前子对象当中的父类特征。</p>
<p>当子类重写父类中的方法函数时，子类需要调用父类中的方法，需要使用super关键字。</p>
<p>super可以用在成员方法中，构造方法中，但不能用于静态方法中。</p>
<pre><code class="language-java">super a;
super(&quot;001&quot;,0.01);
</code></pre>
<p>第二种方法调用的是父类的构造方法</p>
<h3>接口</h3>
<p>接口也是一种引用类型，可以被等同看做类。接口是一个特殊的抽象类，完全抽象。接口中没有构造方法，无法被实例化。接口和接口之间可以多继承。一个类可以实现多个接口，可以看做继承。</p>
<pre><code class="language-java">int interface name{
    //定义一个接口
    //只能出现常量和抽象方法
}
</code></pre>
<p>一个非抽象的类实现接口，需要把接口中的方法<strong>全部</strong>重写</p>
<pre><code class="language-java">class myclass implements aclass,bclass{
    public void m1(){}
    public void m2(){}
}
</code></pre>
<pre><code class="language-java">interface aclass{
    public abstract void m1();
}
</code></pre>
<pre><code class="language-java">interface bclass{
    public abstract void m2();
}
</code></pre>
<h3>访问权限修饰符</h3>
<p>通过访问权限修饰符来规定访问范围。</p>
<p>private &lt; 缺省 &lt; portected &lt; public</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">访问域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">私有，只能在本类中访问</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">可以在同一个包访问</td>
</tr>
<tr>
<td style="text-align:center">portected</td>
<td style="text-align:center">可以在同一个包或子类中访问</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">完全公开，任何地方都可以访问</td>
</tr>
</tbody>
</table>
<h3>buffer缓冲区</h3>
<p>StringBuffer和StringBuilder缓冲区大小默认是16，创建缓冲区前需要考虑大小，否则将浪费内存。</p>
<p>StringBuffer是线程安全的，StringBuilder效率较高。</p>
<pre><code class="language-java">public class test01{
    public static void main(String[] args){
        StringBuffer ab = new StingBuffer(); //默认16
        String[] ins = [&quot;stra&quot;,&quot;strb&quot;,&quot;strc&quot;,&quot;strd&quot;];
        for(int i;i&lt;ins.length();i++){
            if(i==ins.length()-1) ab.append(ins[i]);
            else{
                ab.append(ins[i]);
                ab.append(&quot;,&quot;);
            }
        }
    }
}
</code></pre>
<h3>泛型</h3>
<pre><code class="language-java">int a&lt;int&gt; = 1;
</code></pre>
<p>泛型只能存储单一类型的数据，但可以防止程序出错</p>
<pre><code class="language-java">public class GenericTest05{
    public static void main(String[] args){
        MyClass&lt;String&gt; me = new MyClass&lt;String&gt;();
        me.m1(&quot;JACK&quot;);
    }
}
</code></pre>
<pre><code class="language-java">class MyClass&lt;T&gt;{
    public void m1(T t){
        System.out.println(t);
    }
}
</code></pre>
<p>自定义泛型</p>
<h3>枚举</h3>
<pre><code class="language-java">enum Result{
    SUCCESS,FAIL
}
</code></pre>
<p>定义一个枚举（在主类外）</p>
<pre><code class="language-java">Result.SUCCESS;
</code></pre>
<p>枚举的使用</p>
<h3>时间与日期对象</h3>
<h5>获取当前时间戳</h5>
<pre><code class="language-java">public class DateTest01{
    public static void main(String[] args){
        long now = System.currentTimeMillis();
        System.out.println(now);
    }
}
</code></pre>
<h5>获取当前日历</h5>
<pre><code class="language-java">import java.util.Calendar;
public class DateTest05{
    public static void main(String[] args){
        Calendar e = Calendar.getInstance();//获取当前日历
        int i = c.get(Claendar.DAY_OR_WEEK);//获取星期
        System.out.println(i);//输出
    }
}
</code></pre>
<h5>获取当前系统时间</h5>
<pre><code class="language-java">import java.util.Date;
import java.text.SimpleDateFormat;

public class DateTest02{
    public static void main(String[] args){
        Date nowTime = new Date();
        SimpleDateFormat adf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;);
        String strTime = sdf.format(nowTime);
        System.out.println(strTime);
    }
}
</code></pre>
<h5>格式化</h5>
<p>日期和时间格式由<em>日期和时间模式</em>字符串指定，在日期和时间模式字符串中，未加引号的“A”到“Z”和“a”到“z”被解释为模式字母，用来表示日期或时间字符串元素，文本可以使用单引号引起来，以免进行解释</p>
<p>定义了以下字母（其他字母保留复制）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">日期或时间元素</th>
<th style="text-align:center">表示</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">Era 标识符</td>
<td style="text-align:center">Text</td>
<td style="text-align:center">AD</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">年</td>
<td style="text-align:center">Year</td>
<td style="text-align:center">1996; 96</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">年中的月</td>
<td style="text-align:center">Month</td>
<td style="text-align:center">July; Jul; 07</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">年中的周</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">27</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">月中的周</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">年中的天</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">159</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">月中的天数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">月中的星期</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">星期中的天数</td>
<td style="text-align:center">Text</td>
<td style="text-align:center">Tuesday; Tue</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">Am/pm标记</td>
<td style="text-align:center">Text</td>
<td style="text-align:center">PM</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">一天中的小时数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">k</td>
<td style="text-align:center">一天中的小时数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">K</td>
<td style="text-align:center">am/pm中的小时数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">am/pm中的小时数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">小时中的分钟数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">分钟中的秒数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">55</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">毫秒数</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">978</td>
</tr>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">时区</td>
<td style="text-align:center">General time rone</td>
<td style="text-align:center">Pacific</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">时区</td>
<td style="text-align:center">RFC 822 time rone</td>
<td style="text-align:center">-0800</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">Date t = new Date(NULL);
System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(t));
</code></pre>
<p>示例</p>
<h3>集合</h3>
<h5>HashMap集合</h5>
<p>HashMap是无序存储的不重复集合</p>
<pre><code class="language-java">import java.util.*;
public class MapTest01{
    public static void main(String[] args)[
        Map p = new HashMap();
    ]
}
</code></pre>
<p>HashMap默认大小是16,扩展因子0.75</p>
<pre><code class="language-java">p.put(&quot;123&quot;,&quot;456&quot;);
</code></pre>
<p>存储key对</p>
<pre><code class="language-java">p.get(&quot;123&quot;);
</code></pre>
<p>获取key对应的value</p>
<pre><code class="language-java">p.clear();
</code></pre>
<p>清空Map</p>
<pre><code class="language-java">p.remove(&quot;123&quot;);
</code></pre>
<p>删除123key对</p>
<pre><code class="language-java">p.size();
</code></pre>
<p>获取个数</p>
<pre><code class="language-java">p.containsKey(&quot;LUCY&quot;);
</code></pre>
<p>判断map中是否有这样的key对</p>
<pre><code class="language-java">p.containsValue(&quot;123&quot;);
</code></pre>
<p>判断map中是否有这样的value对</p>
<pre><code class="language-java">p.values();
</code></pre>
<p>获取所有的value</p>
<pre><code class="language-java">Set keys = p.keySet();
Iterator it2 = keys.iterator();
while(it2.hasNext()){
    Object id = it2.next();
    Object name = p.get(id);
    System.out.println(id+&quot;---&gt;&quot;+name);
}
</code></pre>
<p>遍历HashMap</p>
<pre><code class="language-java">Set entrySet = p.entrySet();
Iterator it3 = entrySet.iterator();
while(it.hasNext()){
    System.out.println(it3.next());
}
</code></pre>
<p>遍历HashMap</p>
<h5>HashSet集合</h5>
<pre><code class="language-java">Set a = new HashSet();
</code></pre>
<p>创建集合</p>
<pre><code class="language-java">a.add(1);
a.add(100);
</code></pre>
<p>存储数据，无序不可重复</p>
<pre><code class="language-java">Iterator it = a.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
</code></pre>
<p>遍历示例</p>
<h3>各种流</h3>
<h5>输入输出流</h5>
<pre><code class="language-java">PrintStream ps = System.out;
ps.println(&quot;JAVA.........&quot;);
</code></pre>
<pre><code class="language-java">System.setOut(new PrintStream(new FileOutputStream(log.log)));
System.out.print(&quot;213&quot;);
</code></pre>
<p>流可以改变输出位置，通常用以上方法记录日志</p>
<h5>文件流</h5>
<pre><code class="language-java">FileInputStream f1 = new FileInputStream(&quot;Test02.txt&quot;);
</code></pre>
<p>文件字节输入流</p>
<pre><code class="language-java">FileReader f2 = new FileReader(&quot;Test02.txt&quot;);
</code></pre>
<p>文件字符读取流</p>
<pre><code class="language-java">new FileOutputStream(&quot;temp02&quot;,true);
</code></pre>
<p>以追加模式打开文件</p>
<pre><code class="language-java">String abslutePath = f1.getAbsolutePath();
</code></pre>
<p>获取绝对路径</p>
<pre><code class="language-java">f1.read();
</code></pre>
<p>读取一个字节的数据</p>
<pre><code class="language-java">f2.readLine();
</code></pre>
<p>读取一行数据，不包含换行</p>
<pre><code class="language-java">byte[] bytes = new byte[1024];
int i1 = fis.read(bytes);
</code></pre>
<p>一次读取1024字节，需要限制一次输出的个数，因为如果字数不足，上次读取的数据不会被销毁</p>
<pre><code class="language-java">f1.length();
</code></pre>
<p>获取文件的字节大小</p>
<pre><code class="language-java">File f3 = new File(&quot;D:\\&quot;);
File[] fs = f3.listFiles();
for(File f:fs)[
    if(f.getAbsolutePath.endWith(&quot;.java&quot;)){
        System.out.println(f.getAbsolutePath());
    }
]
</code></pre>
<p>遍历文件夹示例，只显示<code>.java</code>文件</p>
<pre><code class="language-java">f2.getParent();
</code></pre>
<p>获取父路径</p>
<pre><code class="language-java">f1.isDirectory();
f2.isFile();
</code></pre>
<p>判断是否是目录/文件</p>
<pre><code class="language-java">Date t = new Date(f1.lastmodified());
System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(t));
</code></pre>
<p>输出文件最后修改时间</p>
<pre><code class="language-java">f4.mkdir();
f5.createNewFile();
f6.exists();
</code></pre>
<p>创建目录文件和判断是否存在</p>
<h5>二进制文件流</h5>
<pre><code class="language-java">DataInputStream dis = new DataInputStream(new FileInputStream(&quot;temp05&quot;));
</code></pre>
<p>二进制文件输入流，需要提前知道文件存储的格式和顺序</p>
<pre><code class="language-java">DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;temp05&quot;));
</code></pre>
<p>二进制文件输出流，按照特定格式输出</p>
<h5>缓冲区输入输出流</h5>
<pre><code class="language-java">FileInputStream fis = new FileInputStream(&quot;temp06&quot;);
</code></pre>
<p>创建文件字节输入流</p>
<pre><code class="language-java">InputStreamReader isr = new InputStreamReader(fis);
</code></pre>
<p>将字节流转换成字符流</p>
<pre><code class="language-java">BufferedReader br = new BufferedReader(isr);
</code></pre>
<p>将字符流转换成带有缓冲区的字符流</p>
<pre><code class="language-java">String temp = null;
while((temp=br.readLine())!=null){
    System.out.println(temp);
}
br.close();
</code></pre>
<p>读取和关闭</p>
<p>此时只需要关闭最外层的流即可，这属于<strong>装饰者模式</strong></p>
<pre><code class="language-java">BufferedReader br = new BufferedReader(new FileReader(&quot;t.txt&quot;));
</code></pre>
<p>文件字符流引入缓冲区</p>
<h5>对象的存储</h5>
<pre><code class="language-java">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;temp06&quot;));
oos.writeObject(new User(&quot;张三&quot;));
oos.writeObject(new User(&quot;罗...&quot;));
oos.flush();
oos.close();
</code></pre>
<p>完整的存储示例</p>
<h3>多线程</h3>
<h5>创建新线程</h5>
<pre><code class="language-java">public class ThreadTest07{
    public static void main(String[] args) throws Exception{
        Thread t = new P();
        t.setName(&quot;Task1&quot;);
        t.start();
        t.sleep(5000);
        System.out.println(&quot;Hello world!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">class P extends Thread{
    public void run(){
        for(int i = 0;i&lt;200;i++){
            System.out.println(&quot;Task2 is runing...&quot;);
        }
    }
}
</code></pre>
<p>主线程会创建线程，通过<code>t.setName(&quot;Task2&quot;)</code>设置新线程名字为<code>Task2</code>，然后通过<code>t.start()</code>启动线程，线程会调用<code>run</code>方法执行，但是，<code>t.sleep(5000)</code>不是让新线程暂停5秒，而是让主线程暂停5秒。相当于<code>Thread.sleep(5000)</code></p>
<pre><code class="language-java">class p implements Runnable{
    public void run(){
        for(int i=0;i&lt;10;i++){
            System.out.println(&quot;run--&gt;&quot;+i);
        }
    }
}
</code></pre>
<p><strong>推荐使用这种方法来创建线程，保留了类的继承</strong></p>
<h5>线程同步</h5>
<p>对象锁</p>
<pre><code class="language-java">Thread.join(t1);
</code></pre>
<p>当前线程与t1线程合并</p>
<pre><code class="language-java">syncheonised(共享对象){
    需要被同步的代码
}
</code></pre>
<p>通常的线程同步（安全锁），被锁定的类一次性只能一个线程使用</p>
<p>类锁</p>
<pre><code class="language-java">class Myclass{
    public synchronized static void m1(){}
}
</code></pre>
<p>在方法添加<code>synchronized</code>后，线程执行时，程序执行时会找类锁，被锁定的函数一次只能一个线程使用</p>
<h5>线程其他</h5>
<pre><code class="language-java">t.interrupt();
</code></pre>
<p>中断t的睡眠，通常不建议使用，一般通过全局变量标记</p>
<pre><code class="language-java">t.getName();
</code></pre>
<p>可以获取到线程名字</p>
<pre><code class="language-java">Thread t = Thread.currentThread();
</code></pre>
<p>获取当前线程对应的内存地址</p>
<pre><code class="language-java">try{
    Thread.sleep(1000);
}catch(InterruptedException e){
    e.printStackTrace();
}
</code></pre>
<p>由于<code>run</code>方法不能抛出异常，所以<code>sleep</code>方法需要用这种方法捕获异常</p>
<pre><code class="language-java">t1.setPriority(5);
</code></pre>
<p>设置线程优先级，决定线程抢CPU时间片的多少，1-10之间</p>
<pre><code class="language-java">Thread.yield();
</code></pre>
<p>让步一次，让同优先级的线程优先抢占CPU时间片，不能指定休眠时间</p>
<h5>守护线程</h5>
<p>线程分类上可以分为用户线程和守护线程，只有所有用户线程结束之后守护线程才能。Java的回收机制就是一个守护线程。守护线程一般都是无限执行的（while循环）</p>
<pre><code class="language-java">t1.setDaemon(true/false);
</code></pre>
<p>将<code>t1</code>线程设置为用户进程或守护线程，<code>true</code>代表守护线程，<code>false</code>代表用户线程</p>
<p>即使守护线程在程序代码上不会退出，但是守护线程还是会跟着所有用户线程的结束所结束</p>
<h5>定时器</h5>
<p>作用：每隔一段固定的时间执行一段代码（由于计算机环境不稳定，即使代码是准确的，实际应用效果也不一定准确）</p>
<pre><code class="language-java">Timer t = new Timer();
</code></pre>
<p>创建定时器</p>
<pre><code class="language-java">t.schedule(TimerTask task,Date firstTime,long period);
</code></pre>
<p>创建定时任务</p>
<pre><code class="language-java">public class TimerTest01{
    public static void main(String[] args){
		Timer t = new Timer();
		t.schedule(new logTimerTask,new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).parse(&quot;2021-02-16 00:00:00 000&quot;),10*1000);
    }
}
class logTimerTask extends TimerTask{
    public void run(){
        System.out.println(&quot;H B D&quot;);//猜猜这是什么意思
    }
}
</code></pre>
<p>在2020年02月16日0点执行输出<code>H B D</code>，后每隔10秒输出一次</p>
<h5>wait</h5>
<pre><code class="language-java">wait(Timeout);
</code></pre>
<p>等待其他线程调用该线程的<code>notify()</code>方法前一直等待，如果传入超时则超时后也可以继续执行</p>
<pre><code class="language-java">notify();
notifyAll();
</code></pre>
<p>唤醒此对象在监视器上等待的单个和所有线程</p>
<h5>反射</h5>
<p>反射是指调整自己的状态以适配当前的条件，根据自己的状态调整当前的条件，<strong>类似于递归</strong>。</p>
<p><strong>如果使用不当，将会造成较高成本。</strong></p>
<h3>类的存储 - 序列化与反序列化</h3>
<pre><code class="language-java">import java.io.Serializable;
public class User implements Serializable{
    static final long serialVersionUID = 123456789;
    transient String name;
    User(String name){
        this.name = name;
    }
    public String toString(){
        return &quot;User(&quot;+name+&quot;)&quot;;
    }
}
</code></pre>
<p>被序列化的类示例 - 通过类引入属性参加序列化，使用transient来避免属性参加序列化</p>
<pre><code class="language-java">public class Test01{
    public static void main(String[] args) throws Exception{
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;user.DBF&quot;));//这里是一行下来的，由于长度问题自动换行
        User u = new User(&quot;JACK&quot;);
        oos.writeObject(u);
        oos.flush();
        oos.close();
    }
}
</code></pre>
<p>序列化类示例</p>
<pre><code class="language-java">import java.io.*;
public class ObjectInputStreamTest01{
    public static void main(String[] args){
        ObjectInputStream ols = new ObjectInputStream(new FileInputStream(&quot;temp4&quot;));
        Object o = ols.readObject();
        ols.close();
    }
}
</code></pre>
<p>反序列化示例</p>
