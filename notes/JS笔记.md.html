<h2>JAVASCRIPT</h2>
<p>Web前段有3层：</p>
<ul>
<li>HTML： 从语义的角度，描述页面结构</li>
<li>CSS： 从审美的角度，描述样式</li>
<li>JavaScript： 从交互的角度，描述行为</li>
</ul>
<h2>JS的声明提升特性</h2>
<p>Javascript执行之前，会将声明提前，但不会将赋值提前</p>
<pre><code class="language-javascript">console,log(a) //undefind
var a = 5;
console.log(a) //5
</code></pre>
<h2>Typeof运算符</h2>
<pre><code class="language-javascript">typeof 数值 //number
typeof 字符串 //string
typeof 布尔值 //boolean
typeof undefind //undefind
typeof null //object
</code></pre>
<h2>类型转换</h2>
<p>字符串与任何结果相加结果都是字符串，与顺序无关，这类现象被称为隐式转换</p>
<p>在JS中，可以使用类型函数进行直接转换</p>
<pre><code class="language-javascript">let a = Boolean(0) //除了0和NaN会转换为false以外，其余都是true

//特例
123 + &quot;&quot; //&quot;123&quot;
String(0123) // &quot;0123&quot;
0123.toString() // &quot;0123&quot;

Number(&quot;456&quot;)
parseInt(&quot;456&quot;)
parseFloat(&quot;3.1415926&quot;)
</code></pre>
<p>如果传入非法参数可能会得到<code>undefind</code>或<code>NaN</code></p>
<h2>null和undefined</h2>
<p><code>null</code>被专门用来表示一个空的<code>对象</code></p>
<p><code>undefind</code>表示声明了一个变量，但没有被赋值</p>
<p>进行数值运算时，<code>10+null=10</code>，<code>10+undefind=NaN</code>，null可以被当作0看待</p>
<h2>DOM对象</h2>
<pre><code class="language-javascript">document //整个文档
</code></pre>
<pre><code class="language-javascript">document.getElementById(&quot;元素的ID&quot;) //ID取元素（ID具有唯一性）
</code></pre>
<pre><code class="language-javascript">document.getElementsByTagName(&quot;元素的名字&quot;) //name属性取元素（返回数组）
</code></pre>
<pre><code class="language-javascript">document.getElementByClassName(&quot;类名&quot;) //class属性取元素（返回数组）
document.querySelector(&quot;li&quot;)[3].classList.contains(&quot;red&quot;) //是否包含某类名
document.querySelector(&quot;li&quot;).classList.remove(&quot;ClassName&quot;) //移除一个类名
</code></pre>
<pre><code class="language-javascript">document.querySelector(&quot;CSS选择器&quot;) //按照CSS匹配的方式选择元素，只会选择第一个
document.querySelectorALL(&quot;CSS选择器&quot;) //按照CSS匹配的方式选择元素，返回一个数组
</code></pre>
<pre><code class="language-javascript">document.querySelector(&quot;#add&quot;).onclick=function(){ //单点监听点击事件，多次设置会覆盖
    document.querySelector(&quot;li&quot;).classList.add(&quot;red&quot;); //添加一个red类（&lt;li class=&quot;red&quot;&gt;&lt;/li&gt;）
}

document.querySelector(&quot;#add&quot;).addEventListener('click',function() { //多点监听点击事件，多次设置不会覆盖
    document.querySelector(&quot;li&quot;).classList.add(&quot;red&quot;);
}, false) //true代表事件捕获阶段触发， false代表事件冒泡阶段触发

document.querySelector(&quot;#add&quot;).removeEventListener('click',function() { //移除事件，为标记要求格式相同
    document.querySelector(&quot;li&quot;).classList.add(&quot;red&quot;);
}, false)
</code></pre>
<h3>查询DOM节点</h3>
<table>
<thead>
<tr>
<th style="text-align:center">父节点</th>
<th style="text-align:center">兄弟节点</th>
<th style="text-align:center">子节点</th>
<th style="text-align:center">所有子节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">parentNode</td>
<td style="text-align:center">nectSibling</td>
<td style="text-align:center">firstChild</td>
<td style="text-align:center">childNodes</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">nextElementSibling</td>
<td style="text-align:center">firstElementChild</td>
<td style="text-align:center">children</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">previousSibling</td>
<td style="text-align:center">lastChild</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">previousElementSibling</td>
<td style="text-align:center">lastElementChild</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">document.querySelector(&quot;p&quot;).parentNode //其他同理
</code></pre>
<h3>插入DOM节点</h3>
<pre><code class="language-javascript">父节点.appendChild(新节点)
父节点.insertBefore(子节点, 定位子节点)
</code></pre>
<h3>DOM对象的属性</h3>
<p>DOM对象的属性和HTML标签属性几乎是一致的。</p>
<ul>
<li>value  标签的value属性，常在表单元素中使用</li>
<li>innerHTML   双闭合标签中的内容（识别标签）。</li>
<li>innerText   双闭合标签中的内容（不识别标签）。（旧版火狐要用textContent）。</li>
</ul>
<h2>BOM对象</h2>
<p>BOM： Browser Object Model ， 浏览器对象模型。</p>
<ul>
<li>window对象是BOM的顶层（核心）对象，所有对象都是由它延伸出来的，也可以称为window的子对象。</li>
<li>DOM也是BOM的一部分</li>
</ul>
<p>window新建窗口</p>
<pre><code class="language-javascript">window.open(&quot;url&quot;,&quot;_blank&quot;,param)
newWin.moveTo(5,5)
newWin.moveBy()
newWin.resizeTo()
window.resizeBy()
</code></pre>
<p>param参数可以是：</p>
<ul>
<li>name  新窗口的名称，可以为空</li>
<li>features   属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。</li>
<li>fullscreen= (yes/no/1/0) 是否全屏，默认no</li>
<li>channelmode=  (yes/no/1/0) 是否显示频道栏，默认no</li>
<li>toolbar=  (yes/no/1/0) 是否显示工具条，默认no</li>
<li>location=  (yes/no/1/0) 是否显示地址栏，默认no</li>
<li>directories= (yes/no/1/0) 是否显示转向按钮，默认no</li>
<li>status= (yes/no/1/0) 是否显示窗口状态条，默认no</li>
<li>menubar=(yes/no/1/0)是否显示菜单，默认no</li>
<li>scrollbars=(yes/no/1/0)是否显示滚动条，默认yes</li>
<li>resizable=(yes/no/1/0)是否窗口可调整大小，默认no</li>
<li>width=number窗口宽度</li>
<li>height=number窗口高度</li>
<li>top=number窗口距离屏幕顶部距离</li>
<li>left=number窗口距离屏幕左边距离</li>
</ul>
<p>多个参数可用句号隔开，但推荐写入jSON</p>
<pre><code class="language-javascript">window.close() //用于关闭窗口
</code></pre>
<h2>location对象</h2>
<ul>
<li>href  当前地址或赋值跳转</li>
<li>hash   #后面的内容</li>
<li>host   主机名，包含端口</li>
<li>hostname  主机名</li>
<li>pathname   url路径</li>
<li>protocal  当前协议</li>
<li>search    ?后面的内容</li>
</ul>
<h2>控制文件输入</h2>
<pre><code class="language-javascript">var reader = new FileReader();//读取文件，返回DataUEL
var file = document.querySelector(&quot;#myFile&quot;).files;
reader.readAsDataURL(file[0]);
reader.onload=function(){//展示文件内容
    document.querySelector(&quot;img&quot;).src = reader.result;
}
</code></pre>
<p><code>FileReader</code>提供一个完整的事件模型，用来捕获读取文件时的状态，文件内容保存在文件存储对象的result中，file元素读取的文件在文件对象的files数组中，需要把file对象读取到的文件交给reader，事件列表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onabort</td>
<td style="text-align:center">读取文件中断片时触发</td>
</tr>
<tr>
<td style="text-align:center">onerror</td>
<td style="text-align:center">读取错误时触发</td>
</tr>
<tr>
<td style="text-align:center">onload</td>
<td style="text-align:center">文件读取成功完成时触发</td>
</tr>
<tr>
<td style="text-align:center">onloadend</td>
<td style="text-align:center">读取完成时触发，无论成功失败</td>
</tr>
<tr>
<td style="text-align:center">onloadstart</td>
<td style="text-align:center">开始读取时触发</td>
</tr>
<tr>
<td style="text-align:center">onprogress</td>
<td style="text-align:center">读取文件过程中持续触发</td>
</tr>
</tbody>
</table>
<h2>navigator对像</h2>
<p>window.navigator的一些属性可以获取到客户端的一些信息。</p>
<ul>
<li>获取地理位置： 前两项参数，分别是成功之后的回调和失败之后的回调，最后一项是获取当前地理位置的方式，默认为空</li>
</ul>
<pre><code class="language-javascript">//navigator.geolocation.getCurrentPosition(success,error,option);
navigator.geolocation.getCurrentPosition(showPosition,showError,{});
</code></pre>
<ul>
<li>userAgent    浏览器UA，包含系统和浏览器信息</li>
<li>platform       浏览器支持的系统</li>
</ul>
<h2>全屏</h2>
<pre><code class="language-javascript">document.fullscreenElement;
</code></pre>
<p>判断是否正在全屏</p>
<pre><code class="language-javascript">requestFullScreen();
</code></pre>
<p>开启全屏显示</p>
<pre><code class="language-javascript">cancelFullScreen();
</code></pre>
<p>取消全屏显示</p>
<h2>元素拖动</h2>
<p>在元素拖动中，有原元素（以下用A表示），被拖动元素（以下用B表示），目标元素（以下用C表示），拖动过程可以自己测试</p>
<blockquote>
<p>B被鼠标从A拖到了C</p>
</blockquote>
<h3>目标元素（C）事件</h3>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ondragenter</td>
<td style="text-align:center">当拖拽元素（B）进入时调用</td>
</tr>
<tr>
<td style="text-align:center">onfragover</td>
<td style="text-align:center">当在目标元素（C）时调用</td>
</tr>
<tr>
<td style="text-align:center">ondrop</td>
<td style="text-align:center">当在目标元素（C）释放拖拽元素（B）时调用</td>
</tr>
<tr>
<td style="text-align:center">onfragleave</td>
<td style="text-align:center">当鼠标离开目标元素时调用</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">E.ondragover = function(e){
    e.preventDefault();
}
</code></pre>
<p>如果想触发ondreagover事件，则必须阻止默认行为。浏览器默认会阻止此事件触发。</p>
<pre><code class="language-javascript">document.ondrop=function(e){//为保证拖拽的完成，需要把元素添加进来，同时原来位置的该元素会自动删除
    var id = e.dataTransfer.getData(&quot;text/html&quot;);//接收传输过来的数据
    e.target.appendChild(document.getElementById(id));
}
</code></pre>
<h3>被拖拽元素（B）事件</h3>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ondrag</td>
<td style="text-align:center">持续调用</td>
</tr>
<tr>
<td style="text-align:center">ondragstart</td>
<td style="text-align:center">拖拽开始时调用</td>
</tr>
<tr>
<td style="text-align:center">ondragleave</td>
<td style="text-align:center">拖拽时鼠标离开该元素</td>
</tr>
<tr>
<td style="text-align:center">ondragend</td>
<td style="text-align:center">拖拽结束时调用</td>
</tr>
</tbody>
</table>
<pre><code class="language-javascript">var obj=null;//存储B元素，当前为空
document.ondragstart=function(e){
    /*通过事件捕获A*/
    e.tartget.style.opcity = 0.5;//降低不透明度
    e.target.parentNode.style.borderWidth = &quot;5px&quot;;//修改A元素的边框
    obj = e.target;//将B元素存入
    e.dataTransfer.setDate(&quot;text/html&quot;,e.target.id);//传输数据(格式，数据)
}
document.ondragend=function(e){//恢复原状
    e.target.style.opcity=1;//透明度恢复
    e.target.parentNode.style.borderWidth=&quot;1px&quot;;//A边框恢复
}
</code></pre>
<p>格式：<code>text/html</code>，<code>text/url-list</code>。</p>
<p>数据：一般是字符串。</p>
<p><strong>整个传输过程，事件的定义要按照拖拽顺序定义，事件的定义与A元素无瓜</strong></p>
<h2>网络连通检测</h2>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">online</td>
<td style="text-align:center">网络连通时触发</td>
</tr>
<tr>
<td style="text-align:center">onoffline</td>
<td style="text-align:center">掉线时触发</td>
</tr>
</tbody>
</table>
<h2>网页数据存储</h2>
<p>网页存储分为临时存储和永久存储，其中临时存储可以使用5mb内存空间存储数据，永久存储可以使用5mc磁盘空间存储数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">存储方式</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sessionStorage</td>
<td style="text-align:center">临时存储</td>
</tr>
<tr>
<td style="text-align:center">localStorage</td>
<td style="text-align:center">永久存储</td>
</tr>
</tbody>
</table>
<p>这种存储方式只有本页面可读写，占用空间小，清理方便，是一种代替“饼干”的良好存储方式，可保护用户隐私。</p>
<p>以上两种存储方式，均可使用以下函数，其存储模型可参考JSON</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setItem(key,value);</td>
<td style="text-align:center">通过键值对的方式存储数据</td>
</tr>
<tr>
<td style="text-align:center">getItem(key);</td>
<td style="text-align:center">通过key来拿到value</td>
</tr>
<tr>
<td style="text-align:center">removeItem(key);</td>
<td style="text-align:center">通过key删除对应的键值对</td>
</tr>
<tr>
<td style="text-align:center">clear();</td>
<td style="text-align:center">清除该空间存储的内容</td>
</tr>
</tbody>
</table>
<p>两种方式调用方式相同，例子：</p>
<pre><code class="language-javascript">sessionStorage.setItem(&quot;儒雅随和&quot;,&quot;wdnmd&quot;);
alert(sessionStorage.getItem(&quot;儒雅随和&quot;));
</code></pre>
<h2><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">Canvas</a></h2>
<h3>常用方法和属性</h3>
<h4>画直线</h4>
<table>
<thead>
<tr>
<th style="text-align:center">beginPath</th>
<th style="text-align:center">开启一个路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">closePath</td>
<td style="text-align:center">关闭一个路径</td>
</tr>
<tr>
<td style="text-align:center">moveTo(x,y)</td>
<td style="text-align:center">定义线条开始坐标</td>
</tr>
<tr>
<td style="text-align:center">lineTo(x,y)</td>
<td style="text-align:center">定义线条结束坐标</td>
</tr>
<tr>
<td style="text-align:center">strockeStyle</td>
<td style="text-align:center">属性设置或返回信息</td>
</tr>
<tr>
<td style="text-align:center">strocke</td>
<td style="text-align:center">绘制一条路径</td>
</tr>
<tr>
<td style="text-align:center">lineWidth</td>
<td style="text-align:center">设置线宽</td>
</tr>
</tbody>
</table>
<h4>画圆</h4>
<pre><code class="language-javascript">let canvas = document.querySelector(&quot;#cont&quot;)
let ctx = canvas.getContext('2d')
ctx.arc(x, y, 半径, 起始点弧度, 结束点弧度, true/*是否为逆时针*/)

ctx.fillStyle = 'gold'
ctx.fill()

ctx.lineWidth = 10
ctx.strokeStyle = 'red'
ctx.stroke()
</code></pre>
<h4>画矩形</h4>
<pre><code class="language-javascript">fillRect(x, y, width, height)
//绘制一个填充的矩形
strokeRect(x, y, width, height)
//绘制一个矩形的边框
clearRect(x, y, width, height)
//清除指定矩形区域，让清除部分完全透明。
</code></pre>
<h4>画文字</h4>
<pre><code class="language-javascript">fillText(text, x, y [, maxWidth])
strokeText(text, x, y [, maxWidth])
</code></pre>
<h3>放置图片和生成数据</h3>
<pre><code class="language-javascript">ctx.putImageData(imgData, 图片x, 图片y, 画布x, 画布y, width, height)
</code></pre>
<pre><code class="language-javascript">let data = ctx.getImageData(x, y, width, height)
</code></pre>
<h2>Promise承诺</h2>
<p>promese容器中放置了一个异步任务，容器一旦创建就会自动执行，不需要调用。</p>
<pre><code class="language-javascript">//I promise you.
new Promise( ()=&gt;{
    //异步代码，比如http请求
    reject(err) //把容器的状态改为失败，返回错误信息
    resolve(data) //把容器状态改为成功，返回数据
} )
</code></pre>
<p>作用是简化调用函数写法，避免回调函数的使用影响可读性。</p>
<pre><code class="language-javascript">let p1 = new Promise(()=&gt;{
    resolve(123)
})
p1.then((data)=&gt;{console.log(data)},(err)=&gt;{console.log(err)}) //成功与失败都会执行对应的函数
</code></pre>
<p>常用多层级化处理多次调用函数</p>
<pre><code class="language-javascript">new Promise(()=&gt;{resolve(123)}).then((data)=&gt;{ //数据可以多层处理
    return data //当return一个promise时，后续的then也会转化为新的promise的then
}).then((data)=&gt;{
    console.log(data)
})
</code></pre>
<h2>HTTP交互</h2>
<pre><code class="language-javascript">fetch('url', {mode: 'no-cors'}).then((data)=&gt;{}) //常用fetch简化写法和跨域请求（仅当对方服务端支持时）
</code></pre>
<p>可以使用URLSearchParams来整理url</p>
<pre><code class="language-javascript">let query - `q=测试&amp;order=a&amp;filters[&quot;前端&quot;,&quot;后端&quot;]`
const params = new URLSearchParams(query)

for(let p of params) {
    console.log(p) 
    /*
    	['q','测试']
    	['order','a']
    	['filters','[&quot;前端&quot;,&quot;后端&quot;]']
    */
}

params.get('q') //测试
params.has(&quot;order&quot;) //true
params.toString() //【中文字符串经过base64编码，其他部分不变】
params.set(&quot;order&quot;,&quot;desc&quot;) //设置键值
params.append(&quot;pageSize&quot;,&quot;10&quot;) //增加键值
params.delete(&quot;filters&quot;) //删除键值
</code></pre>
<h2>面向对象</h2>
<p>对象的作用是封装信息，对象具有特征（属性）和行为（方法）。</p>
<p>面向对象： 可以创建自定义的类型，很好的支持继承和多态。</p>
<p>面向对象的特征： 封装、继承、多态。</p>
<h3>对象的分类</h3>
<ol>
<li>内置对象：
<ul>
<li>由ES标准中定义的对象，在任何的ES实现中都可以使用</li>
<li>比如： Math、String、Number、Boolean、Function、Object......</li>
</ul>
</li>
<li>宿主对象
<ul>
<li>由JS的运行环境提供的对象，主要是浏览器提供的对象。</li>
<li>比如 BOM DOM 。</li>
</ul>
</li>
</ol>
<h3>对象的创建</h3>
<pre><code class="language-javascript">let obj = new Object() //创建一个基本对象，并调用constructor()
let nobj = {} //创建一个空对象，以键值对存储
function ck(){} //一个函数对象

class v{ //常用定义类
    constructor(id){ //构造函数
        this.id = id //存储传值
    }
}
</code></pre>
<p>可以通过点向对象内添加属性和方法</p>
<pre><code class="language-javascript">let obj = new Object()
obj.name = &quot;cxk&quot;
obj.like = &quot;chicken&quot;
obj.draw = function(){
    console.log(obj.name + &quot; drawing&quot;)
}
</code></pre>
<p>使用delete删除对象值</p>
<pre><code class="language-javascript">class v{
    constructor(){
        this.id = 1
    }
}

let a = new v()
delete a.id
</code></pre>
<h3>原型对象</h3>
<p>所有对象中，都会有<code>prototype</code>和<code>__proto__</code>属性，其均指向构造对象（即定义时写的对象）。</p>
<pre><code class="language-javascript">function Person() {} //构造函数之一

let per1 = new Person()
let per2 = new Person()

console.log(Person.Prototype) //[object object]
console.log(per1.__proto__ == Person.prototype)
</code></pre>
<p>使用<code>in</code>检查对象中是否有某个属性是，如果原型对象中有，也会返回<code>true</code>。可以使用<code>hasOwnProperty()</code>来检查单个对象中的属性。</p>
<p>使用同一个构造函数创建的对象（没有new），叫做一类对象，也将构造函数称为一个类。</p>
<p>通过一个构造函数创建的对象（有new），称为该类的实例。</p>
<p>使用<code>类 instanceof 构造函数</code>来判断<strong>一个对象是否为一个类的实例。</strong></p>
<h3>对象的this</h3>
<p>默认this指向</p>
<pre><code class="language-javascript">window.fn(this) //this == window
</code></pre>
<p><code>bind</code>绑定this指向</p>
<pre><code class="language-javascript">function (){
    console.log(this) //window
}.bind(window)
</code></pre>
<p>箭头函数中的this</p>
<pre><code class="language-javascript">()=&gt;{
    console.log(this) //window (指向外层)
}
</code></pre>
<p><code>call/apply</code>改变this指向</p>
<pre><code class="language-javascript">fn.call(window)
fn.apply(window)
</code></pre>
<h3>参数对象</h3>
<p>在调用函数时，系统会传入两个参数：</p>
<ul>
<li>函数的上下文对象的this</li>
<li>封装实参的对象arguments</li>
</ul>
<pre><code class="language-javascript">function f(){
    console.log(arguments) //参数
    console.log(typeof arguments) //参数对象类别
    console.log(arguments.length) //参数数量
    console.log(arguments.callee) //当前正在执行的函数
    arguments[0] = 99 //更改参数
    console.log(arguments) 
}
f()
</code></pre>
<h3>数组和对象的一些封装好的函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push()</td>
<td style="text-align:center">向数组最后面追加元素，返回数组的新长度</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">删除数组最后面的元素，返回被删除的元素</td>
</tr>
<tr>
<td style="text-align:center">unshift()</td>
<td style="text-align:center">在数组最前面插入元素，返回数组的新长度</td>
</tr>
<tr>
<td style="text-align:center">shift()</td>
<td style="text-align:center">删除数组最前面的元素，返回被删除的元素</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td style="text-align:center">从数组中提取元素，返回提取的元素</td>
</tr>
<tr>
<td style="text-align:center">splice()</td>
<td style="text-align:center">从数组中删除元素，返回剩余元素</td>
</tr>
<tr>
<td style="text-align:center">concat()</td>
<td style="text-align:center">拼合多个数组，返回拼合后的数组</td>
</tr>
<tr>
<td style="text-align:center">join()</td>
<td style="text-align:center">将数组转换为字符串，并返回字符串</td>
</tr>
<tr>
<td style="text-align:center">reverse()</td>
<td style="text-align:center">反转数组，返回反转后的数组</td>
</tr>
<tr>
<td style="text-align:center">sort()</td>
<td style="text-align:center">对元素进行Unicode编码中的顺序进行从大到小的排序</td>
</tr>
<tr>
<td style="text-align:center">forEach()</td>
<td style="text-align:center">对每个元素进行处理，参数为一个回调函数，通常没有返回值</td>
</tr>
<tr>
<td style="text-align:center">map()</td>
<td style="text-align:center">对数组中的每一项进行加工，将组合成新的数组，且不改变原数组</td>
</tr>
<tr>
<td style="text-align:center">filter()</td>
<td style="text-align:center">对数组中的每一项进行回调计算，返回那些return true的元素，不改变原数组</td>
</tr>
<tr>
<td style="text-align:center">every()</td>
<td style="text-align:center">如果遍历回调有一项元素返回false，即返回false，否则返回真，用于校验合格性</td>
</tr>
<tr>
<td style="text-align:center">some()</td>
<td style="text-align:center">只要有一向返回true，即返回true，适合寻找数据或判断其合格性</td>
</tr>
<tr>
<td style="text-align:center">reduce</td>
<td style="text-align:center">单纯循环遍历，与forEach相同</td>
</tr>
<tr>
<td style="text-align:center">indexOf(value)</td>
<td style="text-align:center">从前向后找第一个元素出现的位置</td>
</tr>
<tr>
<td style="text-align:center">lastIndexOf(value)</td>
<td style="text-align:center">从后向前找元素出现的第一个位置</td>
</tr>
<tr>
<td style="text-align:center">find(()=&gt;{})</td>
<td style="text-align:center">找到第一个返回true的元素，并返回元素</td>
</tr>
<tr>
<td style="text-align:center">findIndex(()=&gt;{})</td>
<td style="text-align:center">找到第一个返回true的元素，并返回索引</td>
</tr>
<tr>
<td style="text-align:center">Array.from(arrayLike)</td>
<td style="text-align:center">将伪数组转换为数组</td>
</tr>
<tr>
<td style="text-align:center">Array.of(v1,v2,v3)</td>
<td style="text-align:center">将一系列值转换为数组</td>
</tr>
</tbody>
</table>
<h2>scroll对象</h2>
<p>使用鼠标滚轮滚动网页时，会触发window.onscroll方法</p>
<p>获取任意盒子的宽高，调用者为节点元素。不包括border和margin。</p>
<ul>
<li>scrollWidth = width + padding</li>
<li>scrollHeight = height + padding</li>
</ul>
<p>scrollHeight有一个特点，如果文字超出了盒子，高度为内容的高（包括超出的内容），如果文字没有超出盒子，高度这是盒子的高度。</p>
<h2>一些简单的代码片段</h2>
<h3>Quick Console.log</h3>
<pre><code class="language-javascript">let c = console.log.bind(document)
c(&quot;text&quot;)
</code></pre>
<h3>Spread Operator 展开运算符</h3>
<pre><code class="language-javascript">let num = [1,2,3]
let cp = [...num]
console.log(cp)
</code></pre>
<h3>Truncating any Array</h3>
<pre><code class="language-javascript">let arr = [1,2,3,4,5,6]
arr.length = 3
console.log(arr)
</code></pre>
<h3>Numerical Separator</h3>
<pre><code class="language-javascript">let data = 100_000
console.log(data) //100000
</code></pre>
<h3>Quick Power Calculation</h3>
<pre><code class="language-javascript">console.log(Math.pow(4,5)) //1024
console.log(4**5) //1024
</code></pre>
<h3>Rest Parameter</h3>
<pre><code class="language-javascript">function sum(...num){
    let cal = 0
    for (let a of num){
        cal += a
    }
    console.log(cal)
}
sum(1,2,3,4,5,6,7,8,9,10)
</code></pre>
<h3>Smart Short Loop</h3>
<pre><code class="language-javascript">const a = [1,2,3,4,5,6]
for(let n of a) console.log(n)
</code></pre>
<h3>CSS Module Script</h3>
<pre><code class="language-javascript">import styles from &quot;./style.css&quot; assert { type: 'css' }
document.adoptedStyleSheets = [style]
</code></pre>
<h3>JS操作剪贴板</h3>
<pre><code class="language-javascript">navigator.clipboard
	.readText()
	.then((text)=&gt;{
    console.log(text)
})
</code></pre>
<pre><code class="language-javascript">navigator.clipboard
	.writeText(text)
	.then(()=&gt;{
    alert(&quot;复制成功！&quot;)
})
</code></pre>
<h3>数组去重</h3>
<pre><code class="language-javascript">let arr = [1,1,2,3,4,4,1,2,2,3]
let uniqueArr = [...new Set(arr)]
console.log(uniqueArr)
</code></pre>
<pre><code class="language-javascript">let arr = [1,1,2,3,4,4,1,2,2,3]
let uniqueArr = (arr) =&gt; [...new Set(arr)]
console.log(uniqueArr(arr))
</code></pre>
<h3>随机字符串</h3>
<pre><code class="language-javascript">const randomString = () =&gt; Math.random().toString(36).slice(2)
console.log(ramdomString())
</code></pre>
<h3>交换两个变量</h3>
<pre><code class="language-javascript">let foo = 'foo'
let bar = 'bar'
[foo,bar] = [bar,foo]
</code></pre>
<h3>防抖</h3>
<pre><code class="language-javascript">//操作时不执行，确认不操作了才执行
function debounce(fun,delay) {
    let timer
    return function() {
        if(timer) clearTimeout(timer)
        let args = arguments
        timer = setTimeout(()=&gt;{
            fun.apply(this, args)
        }, delay)
    }
}
</code></pre>
<h3>节流</h3>
<pre><code class="language-javascript">//定时发送时段内数据包
function throttle(fun, time) {
    let start = 0
    return function() {
        let now = new Date()
        if(now - start &gt; time){
            fun.apply(this, arguments)
            start = now
        }
    }
}
</code></pre>
<h2>Web性能计算</h2>
<h3>网页加载时间</h3>
<pre><code class="language-javascript">const t = window.performance.timing
let time = []

//DNS用时
time.DNSTime = t.domainLookupEnd - t.domainLookupStart

//在TCP上SSL的耗时
time.TCPTime = t.connectEnd - t.connectStart

//服务器响应用时
//同时这也是 Chrome Tools 对TTFB的定义
time.ServerResponseTime = t.responseStart - t.requestStart

//重定向用时
time.RedirectTime = t.redirectEnd - t.redirectStart

//页面下载时间
time.PageDownloadTime = t.responseEnd - t.responseStart

//TTFB用时
//这里的TTFB用时包括了TCP、SSL、DNS时间
time.TTFBTime = t.responseStart - t.navigationStart

//从页面加载到DOMContentLoaded用时
time.ContentLoadingTime = t.domContentLoadedEventStart - t.navigationStart

//在load事件上的耗时
time.loadEventTime = t.loadEvent = t.loadEventEnd - t.loadEventStart

//DOM用时（包括资源加载和DOM树的解析和构建）
time.DOMReady = t.domComplete - t.responseEnd

//页面加载完成的时间
//从页面开始载入到绑定在load事件上的函数全部执行完毕
time.PageLoadTime = t.loadEventEnd - t.navigationStart

//DOM交互用时
time.DOMInteractiveTime = t.domInteractive - t.domLoading
</code></pre>
